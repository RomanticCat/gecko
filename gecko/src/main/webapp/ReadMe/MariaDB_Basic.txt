JDBC Connection String 
   >> jdbc:mariadb://localhost:3306/mvc01?useUnicode=yes&amp;characterEncoding=UTF-8
JDBC Driver Name
   >> org.mariadb.jdbc.Driver


> "C:\mariadb\bin\mysqld.exe" "--defaults-file=C:\mariadb\data\my.ini" "MySQL"
----------      my.ini     -----------------------
[mysqld]
datadir=C:/mariadb/data
port=3306
sql_mode="STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION"
default_storage_engine=innodb
innodb_buffer_pool_size=256M
innodb_log_file_size=50M
character-set-server=utf8
[client]
port=3306
--------------------------------------------------

> mysqladmin -u root -p create mvc01   (-> delete > mysql -u root -p mvc01 -h 127.0.0.1 > drop database mvc02 > show databases)
> mysqlshow -u root -p
> mysql -u root -p mvc01 -h 127.0.0.1

show tables;
# create table mvc_news ( seq int primary key auto_increment, title varchar(100) not null, bbs_contents varchar(2000) not null, writer varchar(50) not null, regdate timestamp, moddate timestamp, hit int, filesrc varchar(1000) ) DEFAULT CHARSET=utf8 ;
# alter table mvc_news drop column filesrc ;
# alter table mvc_news add column filename varchar(200), add column filesrc varchar(1000);
# drop table mvc_news
create table mvc_news ( seq int primary key auto_increment, title varchar(100) not null, bbs_contents varchar(2000) not null, writer varchar(50) not null, regdate timestamp, moddate timestamp, hit int, filename varchar(200), filesrc varchar(1000) ) DEFAULT CHARSET=utf8 ;
show tables;
desc mvc_news;
alter table mvc_news add index index_mvc_news (seq);
show index from mvc_news;
# alter table mvc_news drop index index_mvc_news (seq);
alter table mvc_news add unique unique_mvc_news_title (title);
# alter table mvc_news drop unique unique_mvc_news_title (title);

# delete from mvc_news where title='Welcome to SpringMVC1XXX' ;
# update mvc_news set writer='J', moddate=now() where title='Welcome to SpringMVC1XXX' ;
# select * from mvc_news where seq < 5;

> mysqladmin -u root -p shutdown

-----------------------------
 >>> rownum ...

MariaDB [db01]> select @RN:=@RN+1 as ROWNUM, tbl.* from (
    ->      select * from tb01 where wtime >= '01:10:00' ) as tbl,
    ->      ( select @RN:=0) as r
    ->         order by tbl.grade desc, tbl.seq_val desc
    ->         ;
+--------+---------+-------+------+-------+-----------+------------+----------+
| ROWNUM | seq_val | grade | name | addr  | tel       | wdate      | wtime    |
+--------+---------+-------+------+-------+-----------+------------+----------+
|      1 |       4 |     3 | KWON | Seoul | 1524-5000 | 2013-03-10 | 03:10:01 |
|      2 |       1 |     3 | KIM  | Seoul | 1234-2000 | 2013-03-04 | 01:10:00 |
|      3 |       2 |     2 | PARK | Seoul | 1314-3000 | 2013-02-04 | 05:10:35 |
|      4 |       3 |     1 | CHOI | BUSAN | 1414-4000 | 2013-01-04 | 01:20:00 |
+--------+---------+-------+------+-------+-----------+------------+----------+
4 rows in set (0.00 sec)


==> 
		select * from  (	
		select @RN:=@RN+1 as ROWNUM, tbl.* from (	
			select * from tb_clientside WHERE title like '%7%' ) as tbl,
		(select @RN:=0) as r order by tbl.ref_no desc, tbl.ref_step asc  
		) as tbl_rownum where tbl_rownum.rownum between 2 and 11;	

-----------------------------





C:\MariaDB 5.5\bin> mysqld

 >>> change default pasword from '' to '1234' : type the 'enter' for 'Enter password:'
C:\MariaDB 5.5\bin> mysqladmin -u root -p password 1234
Enter password:

C:\MariaDB 5.5\bin>


C:\MariaDB 5.5\bin> mysqladmin -u root -p ping
Enter password: ********
mysqld is alive

C:\MariaDB 5.5\bin> mysqlshow -u root -p
Enter password: ********
+--------------------+
|     Databases      |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+

C:\MariaDB 5.5\bin> mysqlshow -u root -p mysql
Enter password: ********
Database: mysql
+---------------------------+
|          Tables           |
+---------------------------+
| columns_priv              |
| db                        |
| event                     |
| func                      |
| general_log               |
| help_category             |
| help_keyword              |
| help_relation             |
| help_topic                |
| host                      |
| ndb_binlog_index          |
| plugin                    |
| proc                      |
| procs_priv                |
| proxies_priv              |
| servers                   |
| slow_log                  |
| tables_priv               |
| time_zone                 |
| time_zone_leap_second     |
| time_zone_name            |
| time_zone_transition      |
| time_zone_transition_type |
| user                      |
+---------------------------+

C:\MariaDB 5.5\bin> mysqladmin -u root -p create db01
Enter password: ********

C:\MariaDB 5.5\bin> mysqlshow -u root -p
Enter password: ********
+--------------------+
|     Databases      |
+--------------------+
| information_schema |
| db01               |
| mysql              |
| performance_schema |
| test               |
+--------------------+


C:\MariaDB 5.5\bin> mysql -u root -p db01 -h 127.0.0.1
Enter password: ********
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 43
Server version: 5.5.29-MariaDB mariadb.org binary distribution

Copyright (c) 2000, 2012, Oracle, Monty Program Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [db01]> show tables;
Empty set (0.00 sec)

MariaDB [db01]> quit
Bye

C:\MariaDB 5.5\bin> mysql -u root -h 127.0.0.1 -p
Enter password: ********
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 51
Server version: 5.5.29-MariaDB mariadb.org binary distribution

Copyright (c) 2000, 2012, Oracle, Monty Program Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db01               |
| mysql              |
| performance_schema |
| test               |
+--------------------+
5 rows in set (0.00 sec)

MariaDB [(none)]> use db01;
Database changed
MariaDB [db01]>

MariaDB [db01]> select version(), current_date(), now();
+----------------+----------------+---------------------+
| version()      | current_date() | now()               |
+----------------+----------------+---------------------+
| 5.5.29-MariaDB | 2013-03-12     | 2013-03-12 17:30:44 |
+----------------+----------------+---------------------+
1 row in set (0.00 sec)

MariaDB [db01]> show tables;
Empty set (0.00 sec)

MariaDB [db01]> create table tb01(number integer, name char(10));
Query OK, 0 rows affected (0.08 sec)

MariaDB [db01]> show tables;
+----------------+
| Tables_in_db01 |
+----------------+
| tb01           |
+----------------+
1 row in set (0.00 sec)

MariaDB [db01]>

MariaDB [db01]> show columns from tb01;
+--------+----------+------+-----+---------+-------+
| Field  | Type     | Null | Key | Default | Extra |
+--------+----------+------+-----+---------+-------+
| number | int(11)  | YES  |     | NULL    |       |
| name   | char(10) | YES  |     | NULL    |       |
+--------+----------+------+-----+---------+-------+
2 rows in set (0.02 sec)

MariaDB [db01]> desc tb01;
+--------+----------+------+-----+---------+-------+
| Field  | Type     | Null | Key | Default | Extra |
+--------+----------+------+-----+---------+-------+
| number | int(11)  | YES  |     | NULL    |       |
| name   | char(10) | YES  |     | NULL    |       |
+--------+----------+------+-----+---------+-------+
2 rows in set (0.02 sec)
MariaDB [db01]> insert into tb01 (number, name) values (1, 'whisper');
Query OK, 1 row affected (0.03 sec)

MariaDB [db01]> select * from tb01;
+--------+---------+
| number | name    |
+--------+---------+
|      1 | whisper |
+--------+---------+
1 row in set (0.00 sec)

MariaDB [db01]> alter table tb01 add column address char(15);
Query OK, 1 row affected (0.20 sec)
Records: 1  Duplicates: 0  Warnings: 0

MariaDB [db01]> desc tb01;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| number  | int(11)  | YES  |     | NULL    |       |
| name    | char(10) | YES  |     | NULL    |       |
| address | char(15) | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
3 rows in set (0.02 sec)

MariaDB [db01]>
MariaDB [db01]> alter table tb01 drop column address;
Query OK, 1 row affected (0.29 sec)
Records: 1  Duplicates: 0  Warnings: 0

MariaDB [db01]> desc tb01;
+--------+----------+------+-----+---------+-------+
| Field  | Type     | Null | Key | Default | Extra |
+--------+----------+------+-----+---------+-------+
| number | int(11)  | YES  |     | NULL    |       |
| name   | char(10) | YES  |     | NULL    |       |
+--------+----------+------+-----+---------+-------+
2 rows in set (0.02 sec)

MariaDB [db01]>
MariaDB [db01]> alter table tb01 add column address char(10), add column wdate d
ate, add column wtime time;
Query OK, 1 row affected (0.21 sec)
Records: 1  Duplicates: 0  Warnings: 0

MariaDB [db01]> desc tb01;
+---------+----------+------+-----+---------+-------+
| Field   | Type     | Null | Key | Default | Extra |
+---------+----------+------+-----+---------+-------+
| number  | int(11)  | YES  |     | NULL    |       |
| name    | char(10) | YES  |     | NULL    |       |
| address | char(10) | YES  |     | NULL    |       |
| wdate   | date     | YES  |     | NULL    |       |
| wtime   | time     | YES  |     | NULL    |       |
+---------+----------+------+-----+---------+-------+
5 rows in set (0.02 sec)

MariaDB [db01]>
MariaDB [db01]> insert into tb01 (number, name, address, wdate, wtime)
    ->             values (2, 'kim', 'seoul', '2012-03-05', '01:10:04') ;
Query OK, 1 row affected (0.06 sec)

MariaDB [db01]> select * from tb01;
+--------+---------+---------+------------+----------+
| number | name    | address | wdate      | wtime    |
+--------+---------+---------+------------+----------+
|      1 | whisper | NULL    | NULL       | NULL     |
|      2 | kim     | seoul   | 2012-03-05 | 01:10:04 |
+--------+---------+---------+------------+----------+
2 rows in set (0.00 sec)

MariaDB [db01]>
MariaDB [db01]> update tb01 set wdate='2012-03-04', wtime='22:00' where number=1 ;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MariaDB [db01]> select * from tb01;
+--------+---------+---------+------------+----------+
| number | name    | address | wdate      | wtime    |
+--------+---------+---------+------------+----------+
|      1 | whisper | NULL    | 2012-03-04 | 22:00:00 |
|      2 | kim     | seoul   | 2012-03-05 | 01:10:04 |
+--------+---------+---------+------------+----------+
2 rows in set (0.00 sec)

MariaDB [db01]>
MariaDB [db01]> delete from tb01 where number=2 ;
Query OK, 1 row affected (0.03 sec)

MariaDB [db01]> select * from tb01 ;
+--------+---------+---------+------------+----------+
| number | name    | address | wdate      | wtime    |
+--------+---------+---------+------------+----------+
|      1 | whisper | NULL    | 2012-03-04 | 22:00:00 |
+--------+---------+---------+------------+----------+
1 row in set (0.00 sec)

MariaDB [db01]>

MariaDB [db01]> drop table tb01;
Query OK, 0 rows affected (0.03 sec)

MariaDB [db01]> show tables;
Empty set (0.00 sec)



MariaDB [db01]> create table tb01 ( seq_val INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
    ->                                  grade integer,
    ->                                  name char(20),
    ->                                  addr varchar(50),
    ->                                  tel varchar(10),
    ->                                  wdate date,
    ->                                  wtime time
    ->                                  );
Query OK, 0 rows affected (0.07 sec)

MariaDB [db01]> show tables;
+----------------+
| Tables_in_db01 |
+----------------+
| tb01           |
+----------------+
1 row in set (0.00 sec)

MariaDB [db01]> desc tb01;
+---------+-------------+------+-----+---------+----------------+
| Field   | Type        | Null | Key | Default | Extra          |
+---------+-------------+------+-----+---------+----------------+
| seq_val | int(11)     | NO   | PRI | NULL    | auto_increment |
| grade   | int(11)     | YES  |     | NULL    |                |
| name    | char(20)    | YES  |     | NULL    |                |
| addr    | varchar(50) | YES  |     | NULL    |                |
| tel     | varchar(10) | YES  |     | NULL    |                |
| wdate   | date        | YES  |     | NULL    |                |
| wtime   | time        | YES  |     | NULL    |                |
+---------+-------------+------+-----+---------+----------------+
7 rows in set (0.02 sec)

MariaDB [db01]> insert into tb01 (grade, name, addr, tel, wdate, wtime) values ( 3, 'KIM', 'Seoul', '1234-2000', '2013-03-04', '01:10:00');
MariaDB [db01]> insert into tb01 (grade, name, addr, tel, wdate, wtime) values ( 2, 'PARK', 'Seoul', '1314-3000', '2013-02-04', '05:10:35');
MariaDB [db01]> insert into tb01 (grade, name, addr, tel, wdate, wtime) values ( 1, 'CHOI', 'BUSAN', '1414-4000', '2013-01-04', '01:20');
MariaDB [db01]> insert into tb01 (grade, name, addr, tel, wdate, wtime) values ( 3, 'KWON', 'Seoul', '1524-5000', '2013-03-10', '03:10:01');

MariaDB [db01]> select * from tb01;
+---------+-------+------+-------+-----------+------------+----------+
| seq_val | grade | name | addr  | tel       | wdate      | wtime    |
+---------+-------+------+-------+-----------+------------+----------+
|       1 |     3 | KIM  | Seoul | 1234-2000 | 2013-03-04 | 01:10:00 |
|       2 |     2 | PARK | Seoul | 1314-3000 | 2013-02-04 | 05:10:35 |
|       3 |     1 | CHOI | BUSAN | 1414-4000 | 2013-01-04 | 01:20:00 |
|       4 |     3 | KWON | Seoul | 1524-5000 | 2013-03-10 | 03:10:01 |
+---------+-------+------+-------+-----------+------------+----------+
4 rows in set (0.00 sec)

MariaDB [db01]> select * from tb01 where wtime >= '01:10:00' order by grade desc;
+---------+-------+------+-------+-----------+------------+----------+
| seq_val | grade | name | addr  | tel       | wdate      | wtime    |
+---------+-------+------+-------+-----------+------------+----------+
|       1 |     3 | KIM  | Seoul | 1234-2000 | 2013-03-04 | 01:10:00 |
|       4 |     3 | KWON | Seoul | 1524-5000 | 2013-03-10 | 03:10:01 |
|       2 |     2 | PARK | Seoul | 1314-3000 | 2013-02-04 | 05:10:35 |
|       3 |     1 | CHOI | BUSAN | 1414-4000 | 2013-01-04 | 01:20:00 |
+---------+-------+------+-------+-----------+------------+----------+
4 rows in set (0.00 sec)

MariaDB [db01]> select * from tb01 where wtime >= '01:10:00' order by grade desc, seq_val desc;
+---------+-------+------+-------+-----------+------------+----------+
| seq_val | grade | name | addr  | tel       | wdate      | wtime    |
+---------+-------+------+-------+-----------+------------+----------+
|       4 |     3 | KWON | Seoul | 1524-5000 | 2013-03-10 | 03:10:01 |
|       1 |     3 | KIM  | Seoul | 1234-2000 | 2013-03-04 | 01:10:00 |
|       2 |     2 | PARK | Seoul | 1314-3000 | 2013-02-04 | 05:10:35 |
|       3 |     1 | CHOI | BUSAN | 1414-4000 | 2013-01-04 | 01:20:00 |
+---------+-------+------+-------+-----------+------------+----------+
4 rows in set (0.00 sec)

MariaDB [db01]> select @RN:=@RN+1 as ROWNUM, tbl.* from (
    ->      select * from tb01 where wtime >= '01:10:00' ) as tbl,
    ->      ( select @RN:=0) as r
    ->         order by tbl.grade desc, tbl.seq_val desc
    ->         ;
+--------+---------+-------+------+-------+-----------+------------+----------+
| ROWNUM | seq_val | grade | name | addr  | tel       | wdate      | wtime    |
+--------+---------+-------+------+-------+-----------+------------+----------+
|      1 |       4 |     3 | KWON | Seoul | 1524-5000 | 2013-03-10 | 03:10:01 |
|      2 |       1 |     3 | KIM  | Seoul | 1234-2000 | 2013-03-04 | 01:10:00 |
|      3 |       2 |     2 | PARK | Seoul | 1314-3000 | 2013-02-04 | 05:10:35 |
|      4 |       3 |     1 | CHOI | BUSAN | 1414-4000 | 2013-01-04 | 01:20:00 |
+--------+---------+-------+------+-------+-----------+------------+----------+
4 rows in set (0.00 sec)


MariaDB [db01]> quit
Bye

C:\MariaDB 5.5\bin>


C:\MariaDB 5.5\bin> mysqlshow -u root -p
Enter password: ********
+--------------------+
|     Databases      |
+--------------------+
| information_schema |
| db01               |
| mysql              |
| performance_schema |
| test               |
+--------------------+

C:\MariaDB 5.5\bin> mysqladmin -u root -p drop db01
Enter password: ********
Dropping the database is potentially a very bad thing to do.
Any data stored in the database will be destroyed.

Do you really want to drop the 'db01' database [y/N] y
Database "db01" dropped

C:\MariaDB 5.5\bin> mysqlshow -u root -p
Enter password: ********
+--------------------+
|     Databases      |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+

C:\MariaDB 5.5\bin>
C:\MariaDB 5.5\bin> mysqladmin -u root -p shutdown
Enter password: ********

C:\MariaDB 5.5\bin>


-------------------------------------------------------
-------------------------------------------------------

명명 규칙
* DATABASE: 최대 64 byte. 디렉토리 이름을 만드는데 사용할 수 있는 모든 문자. '.'는 불가
* TABLE: 최대 64 byte. 파일 이름을 만드는데 사용할 수 있는 모든 문자. '.'는 불가
* COLUMN: 최대 64 byte. 모든 문자.
* ALIAS: 최대 255 byte. 모든 문자.


DATABASE 생성

형식
CREATE DATABASE [IF NOT EXISTS] <DATABASE명>

예
mysql> CREATE DATABASE shopsample;


DATABASE 삭제

형식
DROP DATABASE [IF NOT EXISTS] <DATABASE명>

예
mysql> DROP DATABASE shopsample;


컬럼 타입

컬럼 표기 중 M과 D는 다음과 같은 의미이다.
* M : 해당 컬럼이 표기할 수 있는 최대 자리수
* D : 소수점 자리수


문자 컬럼 타입

[NATIONAL] CHAR(M) [BINARY]
M길이 만큼의 고정 길이 문자열 컬럼. 무조건 M byte 만큼 차지하며 왼쪽으로 정렬된다.
M : 0 ~ 255

CHAR
CHAR(1)과 같다.

[NATIONAL] VARCHAR(M) [BINARY]
가변 길이 문자열 컬럼. 데이터가 저장될 때 문자열 오른쪽의 필요없는 공백은 자동으로 제거되어 저장된다.
M : 0 ~ 65,535

TINYBLOB, TINYTEXT
최대 길이가 255 문자(2^8 - 1)인 BLOB 혹은 TEXT 타입

BLOB, TEXT
최대 길이가 65,535 문자(2^16 - 1)인 BLOB 혹은 TEXT 타입

MEDIUMBLOB, MEDIUMTEXT
최대 길이가 16,777,215 문자(2^24 - 1)인 BLOB 혹은 TEXT 타입

LONGBLOB, LONGTEXT
최대 길이가 4,294,967,295 문자(2^32 - 1)인 BLOB 혹은 TEXT 타입

참고 : BLOB와 TEXT 타입
BLOB는 많은 양의 데이터를 저장할 수 있는 컬럼 타입이다.
TEXT 타입도 BLOB와 같은 기능을 하는 컬럼 타입이다.
BLOB와 TEXT의 유일한 차이점은 정렬이나 문자열 비교시에 BLOB 타입은 대소문자를 구분하고, TEXT 타입은 대소문자를 구분하지 않는 것이다.

BLOB, TEXT 와 VARCHAR가 다른 점

	* BLOB와 TEXT 컬럼은 저장시에 문자열 뒷부분의 공백이 제거되지 않는다.
	* BLOB와 TEXT 컬럼은 DEFAULT 값을 지정할 수 없다.


ENUM('value1', 'value2', ...)
인자로 지정된 value1, value2, ... 중 하나의 값이나 NULL만 저장할 수 있다. 그리고 인자 외의 다른 데이터를 입력하려 할 경우 공백이 입력된다. ENUM 타입의 인자는 최대 65535개 까지 지정 가능하다.

SET('value1', 'value2', ...)
SET은 ENUM과 같은 기능을 하는 컬럼 타입이다. SET은 하나의 컬럼에 인자에 해당하는 여러 개의 데이터를 저장할 수 있다는 것이 차이점이다.

mysql> CREATE TABLE settest (
    -> test1 SET('abc', 'bcd', 'cde')
    -> );
mysql> INSERT INTO settest VALUES ('abc');
mysql> SELECT * FROM settest;
+-------+
| test1 |
+-------+
| abc   |
+-------+
mysql> INSERT INTO settest VALUES ('abc,bcd');
mysql> SELECT * FROM settest;
+---------+
| test1   |
+---------+
| abc     |
| abc,bcd |
+---------+


숫자 컬럼 타입

숫자형 컬럼 타입 중에는 정의할 때 UNSIGNED나 ZEROFILL같은 선택사항을 사용할 수 있는 타입이 있다.
UNSIGNED : 양수
ZEROFILL : 숫자의 나머지 자리를 0으로 채운다. INT(4) ZEROFILL 컬럼에 13이라는 값은 0013 으로 저장된다.

TINYINT[(M)] [UNSIGNED] [ZEROFILL]
정수 타입.
범위: -128 ~ 127. UNSIGNED가 지정되면 0 ~ 255

BIT, BOOL
TINYINT(1)과 같다.

SMALLINT[(M)] [UNSIGNED] [ZEROFILL]
정수 타입.
범위: -32768 ~ 32767. UNSIGNED가 지정되면 0 ~ 65535

MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]
정수 타입.
범위: -8,388,608 ~ 8,388,607. UNSIGNED가 지정되면 0 ~ 16,777,215

INT[(M)] [UNSIGNED] [ZEROFILL]
정수 타입.
범위: -2,147,483,648 ~ 2,147,483,647 (약 21억). UNSIGNED가 지정되면 0 ~ 4,294,967,295

INTEGER[(M)] [UNSIGNED] [ZEROFILL]
INT 와 같다.

BIGINT[(M)] [UNSIGNED] [ZEROFILL]
정수 타입.
범위: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 922경). UNSIGNED가 지정되면 0 ~ 1844경

FLOAT(precision) [UNSIGNED] [ZEROFILL]
부동 소수점 실수. precision은 숫자 전체의 자리수를 나타낸다. 
precision은 단정도(float) 부동 소수점 실수인 경우 24 이하의 값이 오며, 배정도(double) 부동 소수점 실수인 경우 25 ~ 53 사이의 값이 온다.

FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]
단정도 부동 소수점 실수 타입.
범위: -3.402823466E+38 ~ -1.175494351E-38, 1.175494351E-38 ~ 3.402823466E+38
M은 숫자 전체의 길이, D는 소수점 자리수를 의미

DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]
배정도 부동 소수점 실수 타입.
범위: -1.7976931348623157E+308 ~ -2.2250738585072014E-308, 0, 2.2250738585072014E-308 ~ 1.7976931348623157E+308
M은 숫자 전체의 길이, D는 소수점 자리수를 의미

DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL], REAL[(M,D)] [UNSIGNED] [ZEROFILL]
DOUBLE과 같다.

DECIMAL[(M,D)] [UNSIGNED] [ZEROFILL]
CHAR 형태로 부동 소수점 실수를 저장하는 타입이다. 즉, 숫자가 문자형으로 변환되어 저장된다. 범위는 DOUBLE과 같다. 소수점 표시(.)와 마이너스 기호(-)는 데이터의 길이에 포함되지 않는다.

DEC[(M,D)] [UNSIGNED] [ZEROFILL], NUMERIC[(M,D)] [UNSIGNED] [ZEROFILL]
DECIMAL과 같다.


테이블 생성

형식
CREAET [TEMPORARY] TABLE [IF NOT EXISTS] <테이블명> (
    <컬럼명> <컬럼타입> <컬럼제약> [, ...]
    [CONSTRAINT symbol <테이블제약>]
) [<테이블 옵션>]

SELECT문을 이용한 테이블 생성 형식
CREATE TABLE <테이블명>
SELECT <컬럼 리스트>
FROM <테이블명>
WHERE <조건>

SELECT문을 이용하여 테이블을 생성하는 경우, 기존 테이블의 NOT NULL, DEFAULT 제약은 새로운 테이블에 그대로 적용되지만 PRIMARY KEY 제약은 사라진다. 필요시 ALTER TABLE 문을 사용해서 추가한다.


컬럼 제약

NOT NULL
NULL이 저장될 수 없다.

PRIMARY KEY
PRIMARY KEY 컬럼은 반드시 NOT NULL 이 지정되어야 한다. 중복된 데이터가 들어갈 수 없다.
컬럼 제약의 PRIMARY KEY는 테이블에서 오직 하나의 컬럼에만 지정할 수 있다. 만약 하나의 테이블에 두 개 이상의 컬럼을 묶어 PRIMARY KEY로 지정하려면 테이블 제약 부분에 PRIMARY KEY로 지정해야 한다.

UNIQUE
중복된 데이터를 허용하지 않는다. 
UNIQUE는 NULL 값이 저장되는 것을 허용하고 NULL 값에 대해서는 중복을 허용한다.
하나의 테이블에서 여러 개의 컬럼에 대해 UNIQUE 컬럼 제약을 지정할 수 있다.

DEFAULT value
row 생성시 아무 값도 지정되지 않는 경우의 기본값

AUTO_INCREMENT
자동 숫자 증가 컬럼.

REFERENCES
FOREIGN KEY


테이블 제약

PRIMARY KEY(<컬럼 리스트>)
하나의 테이블에 두 개 이상의 컬럼을 한꺼번에 PRIMARY KEY로 지정할 때 사용한다.

UNIQUE(<컬럼 리스트>)
중복된 데이터가 저장될 수 없지만 NULL은 허용한다.

INDEX(<컬럼 리스트>)
인덱스를 지정한다.
PRIMARY KEY, UNIQUE로 지정된 컬럼은 내부적으로 인덱스가 생성된다.


테이블 옵션

TYPE (MySQL 5.x에서 필요한지 확인할 필요 있음)

	* BDB, BerkeleyDB : Page 레벨의 Locking을 지원하는 트랜잭션이 적용된 테이블 타입
	* HEAP : 데이터가 메모리에만 저장되는 타입
	* ISAM : MySQL 3.22 이하에서 사용하던 원래 테이블 타입
	* InnoDB : Row 레벨의 Locking을 지원하는 트랜잭션이 적용된 테이블 타입
	* MERGE : MyISAM 타입의 테이블들의 집합의 형태인 테이블 타입
	* MGR_MyISAM : MERGE 테이블 타입의 별칭
	* MyISAM : ISAM 타입에서 확장된 새로운 테이블 타입


COMMENT
테이블 주석. 60 byte.


테이블 변경

컬럼 추가
ALTER TABLE <테이블명> ADD COLUMN <컬럼명> <컬럼타입> [FIRST | AFTER <컬럼명>]

컬럼 TKRWP
ALTER TABLE <테이블명> DROP COLUMN <컬럼명>

컬럼 변경
ALTER TABLE <테이블명> CHANGE COLUMN <이전 컬럼명> <새 컬럼명> <새 컬럼타입>

테이블명 변경
ALTER TABLE <이전 테이블명> RENAME AS <새 테이블명>

PRIMARY KEY 추가
ALTER TABLE <테이블명> ADD PRIMARY KEY (<컬럼 리스트>)

PRIMARY KEY 삭제
ALTER TABLE <테이블명> DROP PRIMARY KEY


테이블 삭제

형식
DROP TABLE [IF EXISTS] <테이블명> [, <테이블명>, ...]


연산자

* 비교 연산자를 사용하는 경우 조건이 맞으면 1, 틀리면 0을 반환한다.
  select 1 = 0; # 0 반환
  select 1 = 1; # 1 반환

* 문자열과 숫자를 비교하면 자동으로 문자열을 숫자로 변환하여 비교한다.
mysql> select '0' = 0, '0.0' = 0, '0.01' = 0, '.01' = 0.01;
+---------+-----------+------------+--------------+
| '0' = 0 | '0.0' = 0 | '0.01' = 0 | '.01' = 0.01 |
+---------+-----------+------------+--------------+
|       1 |         1 |          0 |            1 |
+---------+-----------+------------+--------------+

* NULL : 아무것도 없음을 나타낸다. 숫자 0이나 문자 공백과는 의미가 다르다. NULL은 아무것도 없는 값이므로 크기를 비교할 수 없다.

* 일반적인 연산자로 NULL과 비교를 하게 되면 결과는 무조건 NULL이 된다. 왜냐하면 NULL은 크기를 비교할 수 없기 때문이다.
mysql> select 1 = null, 1 <> null, null = null, null <> null;
+----------+-----------+-------------+--------------+
| 1 = null | 1 <> null | null = null | null <> null |
+----------+-----------+-------------+--------------+
|     NULL |      NULL |        NULL |         NULL |
+----------+-----------+-------------+--------------+

* <=> (NULL safe equal) 연산자로 비교하면 NULL을 NULL 자체로 인식하여 비교해준다.
mysql> select 1 <=> 1, 1 <=> null, null <=> null;
+---------+------------+---------------+
| 1 <=> 1 | 1 <=> null | null <=> null |
+---------+------------+---------------+
|       1 |          0 |             1 |
+---------+------------+---------------+

* NOT 혹은 ! : 논리적 부정을 의미한다. 마지막 예에서 ! 1 + 1 은 (!1) + 1 과 같기 때문에 결과는 0 + 1 이므로 1이 된다.
mysql> SELECT NOT 1, NOT NULL, !(1 + 1), ! 1 + 1;
+-------+----------+----------+---------+
| NOT 1 | NOT NULL | !(1 + 1) | ! 1 + 1 |
+-------+----------+----------+---------+
|     0 |     NULL |        0 |       1 |
+-------+----------+----------+---------+

* OR 혹은 || : 논리합(OR) 이다.
mysql> SELECT 1 || 0, 0 || 0, 1 || NULL;
+--------+--------+-----------+
| 1 || 0 | 0 || 0 | 1 || NULL |
+--------+--------+-----------+
|      1 |      0 |         1 |
+--------+--------+-----------+

* AND 혹은 && : 논리곱(AND)이다. 대상에 NULL이 있으면 NULL을 반환한다.
mysql> SELECT 1 && 1, 1 && 0, 1 && NULL;
+--------+--------+-----------+
| 1 && 1 | 1 && 0 | 1 && NULL |
+--------+--------+-----------+
|      1 |      0 |      NULL |
+--------+--------+-----------+

* XOR : 배타적 논리합(XOR)이다. a XOR b 는 (a && !b) || (!a && b) 와 같다.
mysql> SELECT 1 XOR 1, 1 XOR 0, 1 XOR NULL;
+---------+---------+------------+
| 1 XOR 1 | 1 XOR 0 | 1 XOR NULL |
+---------+---------+------------+
|       0 |       1 |       NULL |
+---------+---------+------------+

* DISTINCT를 사용하여 중복을 제거할 수 있다.

* GROUP BY의 사용법은 오라클과 동일하다.
mysql> select job, count(*) from customers group by job;
+--------------+----------+
| job          | count(*) |
+--------------+----------+
| 과학자       |        1 |
| 농학자       |        1 |
| 문학가       |        1 |
| 시인         |        3 |
| 의사         |        1 |
| 작곡가       |        1 |
| 지리학자     |        1 |
| 화가         |        1 |
+--------------+----------+

* LIKE 연산자의 와일드 카드에는 '%'(모든 문자)와 '_'(1개의 문자)가 있다.
mysql> select name, email from customers
    -> where email like 'b%';
+--------------+-----------------------+
| name         | email                 |
+--------------+-----------------------+
| 방정환       | bangjh@domain.co.kr   |
| 신사임당     | brushsin@domain.co.kr |
+--------------+-----------------------+
mysql> select name, email
    -> from customers
    -> where email like 'b_____@%';
+-----------+---------------------+
| name      | email               |
+-----------+---------------------+
| 방정환    | bangjh@domain.co.kr |
+-----------+---------------------+

* LIMIT : 원하는 범위만큼 데이터 가져오기
인자를 하나만 지정한 경우에는 조회결과에서 위에서 부터 원하는 수 만큼의 row를 가져온다.
인자를 두개 지정한 경우에는 앞의 인자는 순서를 뛰어넘을 row의 개수이며, 뒤의 인자는 출력을 원하는 row의 개수를 의미한다.
mysql> select * from orders;
+-----------+--------------+-------------+
| orders_id | customers_id | orders_date |
+-----------+--------------+-------------+
|         3 |           12 | 2002-09-05  |
|         7 |            8 | 2002-09-06  |
|         8 |            4 | 2002-09-06  |
|         9 |            4 | 2002-09-08  |
|        13 |           16 | 2002-09-11  |
|        15 |            2 | 2002-09-12  |
|        16 |           15 | 2002-09-12  |
|        17 |            2 | 2002-09-13  |
+-----------+--------------+-------------+
mysql> select * from orders limit 3;
+-----------+--------------+-------------+
| orders_id | customers_id | orders_date |
+-----------+--------------+-------------+
|         3 |           12 | 2002-09-05  |
|         7 |            8 | 2002-09-06  |
|         8 |            4 | 2002-09-06  |
+-----------+--------------+-------------+
mysql> select * from orders LIMIT 3, 2;
+-----------+--------------+-------------+
| orders_id | customers_id | orders_date |
+-----------+--------------+-------------+
|         9 |            4 | 2002-09-08  |
|        13 |           16 | 2002-09-11  |
+-----------+--------------+-------------+




날짜, 시간

http://dev.mysql.com/doc/refman/5.6/en/date-and-time-functions.html

날짜 및 시간 관련 컬럼 타입

DATE

	* 날짜 타입
	* 3 bytes
	* 포맷 : YYYY-MM-DD
	* '1000-01-01'에서 '9999-12'31' 까지 나타낼 수 있다.


DATETIME

	* 날짜와 시간이 합쳐진 타입
	* 8 bytes
	* 포맷 : YYYY-MM-DD hh:mm:ss
	* '1000-01-01 00:00:00'에서 '9999-12'31 23:59:59' 까지 나타낼 수 있다.


TIMESTAMP

	* 날짜 및 시간 타입
	* 포맷 : YYYY-MM-DD hh:mm:ss
	* 4 bytes
	* '1970-01-01 00:00:00'에서 2037년 12월 31일 자정까지를 표현한다.
	* 해당 row의 데이터가 수정된 날짜 값이 자동으로 들어간다.
	* M은 자리수이다.


TIME

	* 시간 타입
	* 3 bytes
	* 포맷 : hh:mm:ss
	* '00:00:00' ~ '23:59:59' 까지 표현 가능


YEAR[(size)]

	* 연도
	* 포맷 : YYYYY
	* 1 byte
	* 2자리나 4자리로 나타낼 수 있으며 default는 4이다.
	* 4자리로 나타낼 때는 1900 ~ 2155, 2자리로 나타낼 경우에는 1970 ~ 2069까지 표현한다.




날짜 및 시간 관련 함수

DAYOFWEEK(date)
지정한 날짜가 그 주의 몇번째 요일인지 반환한다. 1:일요일, 2:월요일, ..., 7:토요일
mysql> select dayofweek('2002-02-03');
+-------------------------+
| dayofweek('2002-02-03') |
+-------------------------+
|                       1 | (일요일)
+-------------------------+

WEEKDAY(date)
DAYOFWEEK와 비슷하나 0:월요일 부터 시작한다. ..., 6:일요일
mysql> select weekday('2002-02-03');
+-----------------------+
| weekday('2002-02-03') |
+-----------------------+
|                     6 | (일요일)
+-----------------------+

DAYOFMONTH(date)
해당 달의 몇 번째 날인지 반환한다.
mysql> select dayofmonth('2002-02-03');
+--------------------------+
| dayofmonth('2002-02-03') |
+--------------------------+
|                        3 |
+--------------------------+

DAYOFYEAR(date)
해당 연도의 몇번째 날인지 반환한다.
mysql> select dayofmonth('2002-02-03');
+--------------------------+
| dayofmonth('2002-02-03') |
+--------------------------+
|                        3 |
+--------------------------+

MONTH(date)
해당 연도의 몇 번째 달인지를 반환한다. 1 ~ 12.
mysql> select month('2002-02-03');
+---------------------+
| month('2002-02-03') |
+---------------------+
|                   2 |
+---------------------+

DAYNAME(date)
해당 날짜의 요일명을 가져온다.
mysql> select month('2002-02-03');
+---------------------+
| month('2002-02-03') |
+---------------------+
|                   2 |
+---------------------+

MONTHNAME(date)
해당 달의 이름을 가져온다.
mysql> select monthname('2002-02-03');
+-------------------------+
| monthname('2002-02-03') |
+-------------------------+
| February                |
+-------------------------+

QUARTER(date)
해당 분기를 반환한다. 1 ~ 4.
mysql> select quarter('2002-02-03');
+-----------------------+
| quarter('2002-02-03') |
+-----------------------+
|                     1 |
+-----------------------+

WEEK(date)
해당 년도의 몇 번째 주인가를 반환한다.
mysql> select quarter('2002-02-03');
+-----------------------+
| quarter('2002-02-03') |
+-----------------------+
|                     1 |
+-----------------------+

YEAR(date)
해당 년도를 반환한다.
mysql> select year('2002-02-03');
+--------------------+
| year('2002-02-03') |
+--------------------+
|               2002 |
+--------------------+

YEARWEEK(date)
연도와 몇번째 주인가를 붙여서 반환한다. 'YYYY(년도)' + '주차'
mysql> select yearweek('2002-02-03');
+------------------------+
| yearweek('2002-02-03') |
+------------------------+
|                 200205 |
+------------------------+

HOUR(time)
시를 반환한다. 0 ~ 23.
mysql> select yearweek('2002-02-03');
+------------------------+
| yearweek('2002-02-03') |
+------------------------+
|                 200205 |
+------------------------+

MINUTE(time)
분을 반환한다. 0 ~ 59.
mysql> select minute('10:05:03');
+--------------------+
| minute('10:05:03') |
+--------------------+
|                  5 |
+--------------------+

SECOND(time)
초를 반환한다. 0 ~ 59.
mysql> select second('10:05:03');
+--------------------+
| second('10:05:03') |
+--------------------+
|                  3 |
+--------------------+

PERIOD_ADD(date, months)
날짜(YYYYMM or YYMM만 가능)에 달의 수를 더한 결과를 반환한다.
mysql> select period_add(201308, 2);
+-----------------------+
| period_add(201308, 2) |
+-----------------------+
|                201310 |
+-----------------------+
mysql> select period_add(1308, 2);
+---------------------+
| period_add(1308, 2) |
+---------------------+
|              201310 |
+---------------------+

PERIOD_DIFF(date1, date2)
YYYYMM 혹은 YYYYMM 형태의 date1과 date2가 몇 달 사이인지 반환한다. (date1 - date2) 형태로 계산된다.
mysql> select period_diff(201301, 201310);
+-----------------------------+
| period_diff(201301, 201310) |
+-----------------------------+
|                          -9 |
+-----------------------------+
mysql> select period_diff(201310, 201301);
+-----------------------------+
| period_diff(201310, 201301) |
+-----------------------------+
|                           9 |
+-----------------------------+

DATE_ADD(date, INTERVAL amount type) == ADDDATE(date, INTERVAL amount type)
전달된 날짜에 type만큼의 amount 시간을 더한 결과를 반환한다.
type과 해당 type에 대한 amount의 포맷은 다음과 같다.

	* SECOND: 초
	* MINUTE: 분
	* HOUR: 시
	* DAY: 일
	* MONTH: 달
	* YEAR: 년
	* MINUTE_SECOND: "분:초"
	* HOUR_MINUTE: "시:분"
	* DAY_HOUR: "일 시"
	* YEAR_MONTH: "년-달"
	* HOUR_SECOND: "시:분:초"
	* DAY_MINUTE: "일 시:분"
	* DAY_SECOND: "일 시:분:초"

mysql> SELECT DATE_ADD("1997-12-31 23:59:59", INTERVAL 1 DAY);
+-------------------------------------------------+
| DATE_ADD("1997-12-31 23:59:59", INTERVAL 1 DAY) |
+-------------------------------------------------+
| 1998-01-01 23:59:59                             |
+-------------------------------------------------+
mysql> SELECT DATE_ADD("1997-12-31 23:59:59", INTERVAL "1:1" MINUTE_SECOND);
+---------------------------------------------------------------+
| DATE_ADD("1997-12-31 23:59:59", INTERVAL "1:1" MINUTE_SECOND) |
+---------------------------------------------------------------+
| 1998-01-01 00:01:00                                           |
+---------------------------------------------------------------+
mysql> SELECT DATE_ADD("1998-01-01 00:00:00", INTERVAL "-1 10" DAY_HOUR);
+------------------------------------------------------------+
| DATE_ADD("1998-01-01 00:00:00", INTERVAL "-1 10" DAY_HOUR) |
+------------------------------------------------------------+
| 1997-12-30 14:00:00                                        |
+------------------------------------------------------------+
mysql> SELECT DATE_ADD("1998-01-30", INTERVAL 1 MONTH);
+------------------------------------------+
| DATE_ADD("1998-01-30", INTERVAL 1 MONTH) |
+------------------------------------------+
| 1998-02-28                               |
+------------------------------------------+

DATE_SUB(date, INTERVAL amount type) == SUBDATE(date, INTERVAL amount type)
전달된 날짜에 type만큼의 amount 시간을 뺀 결과를 반환한다.
mysql> SELECT DATE_SUB("1998-01-02", INTERVAL 5 DAY);
+----------------------------------------+
| DATE_SUB("1998-01-02", INTERVAL 5 DAY) |
+----------------------------------------+
| 1997-12-28                             |
+----------------------------------------+
mysql> SELECT DATE_SUB("1998-03-30", INTERVAL 1 MONTH);
+------------------------------------------+
| DATE_SUB("1998-03-30", INTERVAL 1 MONTH) |
+------------------------------------------+
| 1998-02-28                               |
+------------------------------------------+

EXTRACT(type FROM date)
날짜에서 type에 해당하는 값을 추출하여 반환한다. type은 DATE_ADD(), DATE_SUB()에서 사용하는 type과 같다.
mysql> SELECT EXTRACT(DAY FROM "2013-01-03 12:31:45");
+-----------------------------------------+
| EXTRACT(DAY FROM "2013-01-03 12:31:45") |
+-----------------------------------------+
|                                       3 |
+-----------------------------------------+
mysql> SELECT EXTRACT(HOUR FROM "2013-01-03 12:31:45");
+------------------------------------------+
| EXTRACT(HOUR FROM "2013-01-03 12:31:45") |
+------------------------------------------+
|                                       12 |
+------------------------------------------+

TO_DAYS(date)
날짜가 서기 0년 1월 1일 부터 몇 번째 날인지를 반환한다.
mysql> SELECT TO_DAYS("2013-10-12");
+-----------------------+
| TO_DAYS("2013-10-12") |
+-----------------------+
|                735518 |
+-----------------------+

FROM_DAYS(days)
서기 0년 1월 1일 부터 지정된 날수 만큼에 해당하는 날짜를 반환한다.
mysql> SELECT FROM_DAYS(371);
+----------------+
| FROM_DAYS(371) |
+----------------+
| 0001-01-06     |
+----------------+

DATE_FORMAT(date, format)
날짜를 원하는 문자열 형태로 바꾼다. 포맷은 다음과 같다.

	* %a: 요일의 약어(Sun, Mon, 등)
	* %b: 달의 약어(Jan, Feb, 등)
	* %c: 달의 숫자(1~12)
	* %D: 영문법 서수 표기에 따른 해당 달의 날짜(1st, 2nd)
	* %d: 해당 달의 날짜(01~31)
	* %e: 해당 달의 날짜(1~31)
	* %H: 24시간제 시간(00~23)
	* %h: 12시간제 시간(00~11)
	* %I: 12시간제 시간(00~11)
	* %i: 분(00~59)
	* %j: 해당 년에서 몇 번째 일인지(000~366)
	* %k: 24시간제 시간(0~23)
	* %l: 12시간제 시간(0~11)
	* %M: 달의 이름(January, ..)
	* %m: 달의 숫자(01~12). 2자리임에 주의. '0'이 안붙는 것은 %c
	* %p: AM or PM
	* %r: 12시간 기준으로 시간을 'hh:mm:ss [A|P]M' 형태로 표시
	* %S: 초(00~59)
	* %s: 초(00~59)
	* %T: 24시간 기준으로 시간을 'hh:mm:ss' 형태로 표시
	* %U: 해당 연도에서 몇 번째 주인지(00~53). 일요일이 시작인 주를 기준
	* %u: 해당 연도에서 몇 번째 주인지(00~53). 월요일이 시작인 주를 기준
	* %V: 해당 연도에서 몇 번째 주인지(01~53). 일요일이 시작인 주를 기준. '%X'와 함께 쓰인다.
	* %v: 해당 연도에서 몇 번째 주인지(01~53). 월요일이 시작인 주를 기준. '%x'와 함께 쓰인다.
	* %W: 요일의 이름
	* %w: 요일의 순번(0:일요일)
	* %X: 해당 날짜에 대해 일요일로 시작하는 주를 기준으로 YYYY 형태의 연도를 가져온다. %v와 함께 쓰인다.
	* %x: 해당 날짜에 대해 월요일로 시작하는 주를 기준으로 YYYY 형태의 연도를 가져온다. %v와 함께 쓰인다.
	* %Y: YYYY 형태 연도
	* %y: YY 형태 연도
	* %%: '%' 문자를 나타낸다.

mysql> SELECT DATE_FORMAT(NOW(), '%Y%m%d %H%i%s');
+-------------------------------------+
| DATE_FORMAT(NOW(), '%Y%m%d %H%i%s') |
+-------------------------------------+
| 20131109 233140                     |
+-------------------------------------+

TIME_FORMAT(time, format)
DATE_FORMAT()과 같은 방법으로 사용되며 time에 시간 값이 들어가고 format에는 시, 분, 초에 해당하는 포맷만 들어가야 한다.

STR_TO_DATE(dateStr, format)
DATE_FORMAT()과 같은 포맷이 사용된다.
mysql> SELECT STR_TO_DATE('20140227 134221', '%Y%m%d %H%i%s');
+--------------------------+
|2014-02-27 13:42:21       |
+--------------------------+

CURDATE() == CURRENT_DATE
함수가 문자열로 사용되는 상황인지, 숫자처럼 사용되는 상황인지에 따라 현재 날짜를 'YYYY-MM-DD'(문자열) 혹은 YYYYMMDD(숫자) 형태로 가져온다.
mysql> SELECT CURDATE(), CURRENT_DATE, CURDATE() + 1 - 1;
+------------+--------------+-------------------+
| CURDATE()  | CURRENT_DATE | CURDATE() + 1 - 1 |
+------------+--------------+-------------------+
| 2013-11-09 | 2013-11-09   |          20131109 |
+------------+--------------+-------------------+

CURTIME() == CURRENT_TIME
함수가 문자열로 사용되는 상황인지, 숫자처럼 사용되는 상황인지에 따라 현재 시간을 'HH:MM:SS'(문자열) 혹은 HHMMSS(숫자) 형태로 가져온다.
mysql> SELECT CURTIME(), CURRENT_TIME, CURTIME() + 1 - 1;
+-----------+--------------+-------------------+
| CURTIME() | CURRENT_TIME | CURTIME() + 1 - 1 |
+-----------+--------------+-------------------+
| 23:39:14  | 23:39:14     |            233914 |
+-----------+--------------+-------------------+

NOW() == SYSDATE() == CURRENT_TIMESTAMP
함수가 문자열로 사용되는 상황인지, 숫자처럼 사용되는 상황인지에 따라 현재 날짜와 시간을 'YYYY-MM-DD HH:MM:SS'(문자열) 혹은 YYYYMMDDHHMMSS(숫자) 형태로 가져온다.
참고로 NOW()는 하나의 SELECT 문에 오직 한번만 계산된다. 즉, 하나의 SELECT 문에 여러 개의 NOW()를 사용해도 모두 같은 값을 가져온다.
mysql> SELECT NOW(), NOW() + 1 - 1, SYSDATE(), CURRENT_TIMESTAMP;
+---------------------+----------------+---------------------+---------------------+
| NOW()               | NOW() + 1 - 1  | SYSDATE()           | CURRENT_TIMESTAMP   |
+---------------------+----------------+---------------------+---------------------+
| 2013-11-09 23:41:55 | 20131109234155 | 2013-11-09 23:41:55 | 2013-11-09 23:41:55 |
+---------------------+----------------+---------------------+---------------------+

SEC_TO_TIME(seconds)
초를 시,분,초 형태로 변환한다. 함수가 문자열로 사용되는 상황인지, 숫자처럼 사용되는 상황인지에 따라 'HH:MM:SS' 혹은 HHMMSS 형태로 가져온다.
mysql> SELECT SEC_TO_TIME(2378);
+-------------------+
| SEC_TO_TIME(2378) |
+-------------------+
| 00:39:38          |
+-------------------+

TIME_TO_SEC(time)
time을 초로 변환한다.
mysql> SELECT TIME_TO_SEC('01:01:01');
+-------------------------+
| TIME_TO_SEC('01:01:01') |
+-------------------------+
|                    3661 |
+-------------------------+

DATE(datetime)
datetime을 date로 변환한다. 시/분/초 데이터는 제거된다.
mysql> SELECT DATE(NOW());
+-------------------------+
| DATE(NOW())             |
+-------------------------+
|              2014-08-25 |
+-------------------------+



문자열

http://dev.mysql.com/doc/refman/5.6/en/string-functions.html

모든 문자열 함수에서 문자열의 첫번째 문자의 위치값은 숫자로 1이다.

ASCII(str)
문자열 str의 가장 왼쪽에 있는 문자의 아스키 코드값을 얻는다.
mysql> SELECT ASCII('2');
+------------+
| ASCII('2') |
+------------+
|         50 |
+------------+

ORD(str)
문자열 str의 가장 왼쪽에 있는 문자의 아스키 코드값을 가져온다. 한글가 같이 2byte 이상으로 이루어진 문자에 대해서도 비트 연산을 통해 값을 가져올 수 있다.
mysql> SELECT ORD('2'), ORD('ASDF'), ORD('한2글');
+----------+-------------+----------------+
| ORD('2') | ORD('ASDF') | ORD('한2글')   |
+----------+-------------+----------------+
|       50 |          65 |       15570332 |
+----------+-------------+----------------+

CONV(N, from_base, to_base)
from_base 진수인 숫자 N을 to_base 진수로 변환한다.
mysql> SELECT CONV(8, 10, 2);
+----------------+
| CONV(8, 10, 2) |
+----------------+
| 1000           |
+----------------+

BIN(N)
N을 2진수로 표현한 문자열을 반환한다.
mysql> SELECT BIN(8);
+--------+
| BIN(8) |
+--------+
| 1000   |
+--------+

OCT(N)
N을 8진수로 표현한 문자열을 반환한다.
mysql> SELECT OCT(10);
+---------+
| OCT(10) |
+---------+
| 12      |
+---------+

HEX(N or S)
파라미터가 숫자(N)이면 16진수로 표현한 문자열을 반환하고, 문자열(S)이면 16진수로 변환한 숫자를 반환한다.
mysql> SELECT HEX(255), HEX('ABC');
+----------+------------+
| HEX(255) | HEX('ABC') |
+----------+------------+
| FF       | 414243     |
+----------+------------+

CHAR(N1, N2,...)
N에 해당하는 아스키 코드값들을 문자로 변환한 뒤 합쳐서 하나의 문자열을 가져온다.
mysql> SELECT CHAR(65, 66, 67, 68, 69);
+--------------------------+
| CHAR(65, 66, 67, 68, 69) |
+--------------------------+
| ABCDE                    |
+--------------------------+

CONCAT(str1, str2, ...)
문자열들을 합친다.
mysql> SELECT CONCAT('A', 'BCD');
+--------------------+
| CONCAT('A', 'BCD') |
+--------------------+
| ABCD               |
+--------------------+

CONCAT_WS(separator, str1, str2, ...)
문자열 사이에 구분자를 두어 합친다.
mysql> SELECT CONCAT_WS(',', 'Hello', 'World');
+----------------------------------+
| CONCAT_WS(',', 'Hello', 'World') |
+----------------------------------+
| Hello,World                      |
+----------------------------------+

LENGTH(str), OCTET_LENGTH(str), CHAR_LENGTH(str), CHARACTER_LENGTH(str)
문자열의 길이를 가져온다.
mysql> SELECT LENGTH('str'), OCTET_LENGTH('str'), CHAR_LENGTH('str'), CHARACTER_LENGTH('str');
+---------------+---------------------+--------------------+-------------------------+
| LENGTH('str') | OCTET_LENGTH('str') | CHAR_LENGTH('str') | CHARACTER_LENGTH('str') |
+---------------+---------------------+--------------------+-------------------------+
|             3 |                   3 |                  3 |                       3 |
+---------------+---------------------+--------------------+-------------------------+
mysql> SELECT LENGTH('홍길동'), OCTET_LENGTH('홍길동'), CHAR_LENGTH('홍길동'), CHARACTER_LENGTH('홍길동');
+---------------+---------------------+--------------------+-------------------------+
| LENGTH('   ') | OCTET_LENGTH('   ') | CHAR_LENGTH('   ') | CHARACTER_LENGTH('   ') |
+---------------+---------------------+--------------------+-------------------------+
|             9 |                   9 |                  3 |                       3 |
+---------------+---------------------+--------------------+-------------------------+

BIT_LENGTH(str)
문자열의 길이를 bit 값으로 가져온다.
mysql> SELECT BIT_LENGTH('A'), BIT_LENGTH('ABCD'), BIT_LENGTH('한글');
+-----------------+--------------------+----------------------+
| BIT_LENGTH('A') | BIT_LENGTH('ABCD') | BIT_LENGTH('한글')   |
+-----------------+--------------------+----------------------+
|               8 |                 32 |                   48 |
+-----------------+--------------------+----------------------+

LOCATE(substr, str), POSITION(substr IN str)
str에서 substr이 처음 나타나는 지점의 위치를 가져온다.
mysql> SELECT LOCATE('C', 'ABCD');
+---------------------+
| LOCATE('C', 'ABCD') |
+---------------------+
|                   3 |
+---------------------+

LOCATE(substr, str, pos)
str에서 pos 위치부터 시작해서 substr이 처음 나타나는 지점의 위치를 가져온다.
mysql> SELECT LOCATE('C', 'ABCDABCD', 5);
+----------------------------+
| LOCATE('C', 'ABCDABCD', 5) |
+----------------------------+
|                          7 |
+----------------------------+

INSTR(str, substr)
str에서 substr이 처음 나타나는 지점위 위치를 가져온다. LOCATE(substr, str)와 기능은 같으나 인자 순서가 바뀌었다.
mysql> SELECT INSTR('ABCD', 'C');
+--------------------+
| INSTR('ABCD', 'C') |
+--------------------+
|                  3 |
+--------------------+

LPAD(str, len, padstr)
문자열이 len 만큼 길이가 될 때까지 str의 왼쪽에 padstr을 계속 붙인다.
mysql> SELECT LPAD('ABC', 5, '_'), LPAD('ABC', 10, '-+');
+---------------------+-----------------------+
| LPAD('ABC', 5, '_') | LPAD('ABC', 10, '-+') |
+---------------------+-----------------------+
| __ABC               | -+-+-+-ABC            |
+---------------------+-----------------------+

RPAD(str, len, padstr)
문자열이 len 만큼 길이가 될 때까지 str의 오른쪽에 padstr을 계속 붙인다.
mysql> SELECT RPAD('ABC', 5, '_'), RPAD('ABC', 10, '-+');
+---------------------+-----------------------+
| RPAD('ABC', 5, '_') | RPAD('ABC', 10, '-+') |
+---------------------+-----------------------+
| ABC__               | ABC-+-+-+-            |
+---------------------+-----------------------+

LEFT(str, len)
str 문자열에서 len 길이만큼 왼쪽부터 잘라서 가져온다.
mysql> SELECT LEFT('ABCDEFG', 3);
+--------------------+
| LEFT('ABCDEFG', 3) |
+--------------------+
| ABC                |
+--------------------+

RIGHT(str, len)
str 문자열에서 len 길이만큼 오른쪽부터 잘라서 가져온다.
mysql> SELECT RIGHT('ABCDEFG', 3);
+---------------------+
| RIGHT('ABCDEFG', 3) |
+---------------------+
| EFG                 |
+---------------------+

SUBSTRING(str, pos, len), SUBSTRING(str FROM pos FOR len), MID(str, pos, len)
문자열 str에서 pos 위치부터 len 길이만큼 잘라낸다.
mysql> SELECT SUBSTRING('ABCDEFG', 2, 3), MID('ABCDEFG', 2, 3);
+----------------------------+----------------------+
| SUBSTRING('ABCDEFG', 2, 3) | MID('ABCDEFG', 2, 3) |
+----------------------------+----------------------+
| BCD                        | BCD                  |
+----------------------------+----------------------+

SUBSTRING(str, pos), SUBSTRING(str FROM pos)
문자열 str에서 pos 위치부터 끝까지 잘라낸다.
mysql> SELECT SUBSTRING('ABCDEFG', 2);
+-------------------------+
| SUBSTRING('ABCDEFG', 2) |
+-------------------------+
| BCDEFG                  |
+-------------------------+

SUBSTRING_INDEX(str, delim, count)
문자열 str에서 첫 문자 부터 구분자 delim의 count 번째 위치만큼 잘라낸다. count가 양수이면 문자열의 왼쪽에서부터 delim의 순서를 세고, count가 음수이면 문자열의 오른쪽에서부터 delim의 순서를 센다.
mysql> SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
+------------------------------------------+
| SUBSTRING_INDEX('www.mysql.com', '.', 2) |
+------------------------------------------+
| www.mysql                                |
+------------------------------------------+
mysql> SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
+-------------------------------------------+
| SUBSTRING_INDEX('www.mysql.com', '.', -2) |
+-------------------------------------------+
| mysql.com                                 |
+-------------------------------------------+

LTRIM(str)
문자열 왼쪽의 모든 공백을 제거한다.
mysql> SELECT LTRIM('  bar');
+----------------+
| LTRIM('  bar') |
+----------------+
| bar            |
+----------------+

RTRIM(str)
문자열 오른쪽의 모든 공백을 제거한다.
mysql> SELECT RTRIM('  bar   ');
+-------------------+
| RTRIM('  bar   ') |
+-------------------+
|   bar             |
+-------------------+

TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)
문자열 str로 부터 양쪽으로 모든 removeStr을 제거한다. removeStr이 지정되지 않으면 공백 문자를 제거한다.
mysql> SELECT TRIM('  bar   ');
+------------------+
| TRIM('  bar   ') |
+------------------+
| bar              |
+------------------+
mysql> SELECT TRIM('-' FROM '---bar---');
+----------------------------+
| TRIM('-' FROM '---bar---') |
+----------------------------+
| bar                        |
+----------------------------+

SPACE(N)
N개의 공백문자열을 반환한다.
mysql> SELECT CONCAT('|', SPACE(6), '|');
+----------------------------+
| CONCAT('|', SPACE(6), '|') |
+----------------------------+
| |      |                   |
+----------------------------+

REPLACE(str, from_str, to_str)
문자열 str에서 from_sr 문자열을 to_str 문자열로 바꾼다. multi-byte safe 하다.
mysql> SELECT REPLACE('새우깡', '새우', '감자');
+------------------------------------------+
| REPLACE('새우깡', '새우', '감자')        |
+------------------------------------------+
| 감자깡                                   |
+------------------------------------------+

REPEAT(str, count)
문자열 str을 count 횟수만큼 반복하여 반환한다.
mysql> SELECT REPEAT('A', 5);
+----------------+
| REPEAT('A', 5) |
+----------------+
| AAAAA          |
+----------------+
mysql> SELECT REPEAT('ABC', 5);
+------------------+
| REPEAT('ABC', 5) |
+------------------+
| ABCABCABCABCABC  |
+------------------+

REVERSE(str)
문자열 str의 문자 순서를 반대로 반환한다.
mysql> SELECT REVERSE('ABC');
+----------------+
| REVERSE('ABC') |
+----------------+
| CBA            |
+----------------+
mysql> SELECT REVERSE('새우깡');
+----------------------+
| REVERSE('새우깡')    |
+----------------------+
| 깡우새               |
+----------------------+

INSERT(str, pos, len, newstr)
문자열 str을 pos 위치부터 len 길이만큼 잘라내버리고 그 자리를 newstr로 대체한다.
mysql> SELECT INSERT('Quadratic', 3, 4, 'What'), INSERT('Quadratic', 3, 100, 'What');
+-----------------------------------+-------------------------------------+
| INSERT('Quadratic', 3, 4, 'What') | INSERT('Quadratic', 3, 100, 'What') |
+-----------------------------------+-------------------------------------+
| QuWhattic                         | QuWhat                              |
+-----------------------------------+-------------------------------------+

ELT(N, str1, str2, str3, ...)
인자로 넘어온 문자열 목록(str1, str2, ...) 중에서 N번째 항목(ELemenT)에 해당하는 문자열을 반환한다.
mysql> SELECT ELT(4, 'ej', 'Heja', 'hej', 'foo');
+------------------------------------+
| ELT(4, 'ej', 'Heja', 'hej', 'foo') |
+------------------------------------+
| foo                                |
+------------------------------------+

FIELD(str, str1, str2, str3, ...)
str이 문자열 목록(str1, ...)중에서 몇 번째인지 순서를 반환한다.
mysql> SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
+------------------------------------------------+
| FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo') |
+------------------------------------------------+
|                                              2 |
+------------------------------------------------+

FIELD_IN_SET(str, strlist)
컴마(',')로 구분된 문자열 strlist에서 str이 몇 번째 문자열인지를 반환한다. str에 ','가 포함되어 있으면 제대로 동작하지 않는다.
mysql> SELECT FIND_IN_SET('b','a,b,c,d');
+----------------------------+
| FIND_IN_SET('b','a,b,c,d') |
+----------------------------+
|                          2 |
+----------------------------+

LCASE(str), LOWER(str)
문자열 str을 소문자로 반환한다.
mysql> SELECT LOWER('QUADRATICALLY');
        -> 'quadratically'

UCASE(str), UPPER(str)
문자열 str을 대문자로 반환한다.
mysql> SELECT UPPER('Hej');
        -> 'HEJ'

LOAD_FILE(file_name)
시스템의 파일로 부터 값을 읽어들인다.
file_name은 절대경로이며 권한이 있어야 한다. 그렇지 않으면 NULL을 반환한다.

QUOTE(str)
문자열에 작은 따옴표가 있으면 이스케이프 처리를 해 준다(''' -> '\'')
mysql> SELECT QUOTE('Don\'t!'); <-- SQL문장에서 '''가 들어있으면 오류가 발생할 수 있기 때문에 미리 역슬래쉬 처리함
+------------------+
| QUOTE('Don\'t!') |
+------------------+
| 'Don\'t!'        |
+------------------+

expr [NOT] LIKE pattern [ESCAPE escapeChar]
와일드카드는 '%', '_'가 사용되며 와일드카드에 해당하는 문자 자체를 검색하고 싶다면 앞에 역슬래쉬('\')를 붙여준다.
mysql> SELECT 'David!' LIKE 'David_', 'David!' LIKE 'David\_';
+------------------------+-------------------------+
| 'David!' LIKE 'David_' | 'David!' LIKE 'David\_' |
+------------------------+-------------------------+
|                      1 |                       0 |
+------------------------+-------------------------+
검색하려는 패턴에서 생략하고 싶은 문자가 있으면 ESCAPE 옵션을 사용하면 된다.
mysql> SELECT 'David_' LIKE 'David|_' ESCAPE '|';
+------------------------------------+
| 'David_' LIKE 'David|_' ESCAPE '|' |
+------------------------------------+
|                                  1 |
+------------------------------------+

expr [NOT] RLIKE [BINARY] pattern, expr [NOT] REGEXP [BINARY] pattern
정규표현식을 이용하여 패턴을 검색하고자 할 때 사용된다.
정규표현식은 http://dev.mysql.com/doc/refman/5.6/en/regexp.html#operator_regexp 을 참고한다.
정규표현식은 대소문자를 구분하지 않는다. 대소문자를 구분하려면 BINARY를 적용해야 한다.
mysql> SELECT 'a' REGEXP '^[a-d]', 'a' REGEXP 'A', 'a' REGEXP BINARY 'A';
+---------------------+----------------+-----------------------+
| 'a' REGEXP '^[a-d]' | 'a' REGEXP 'A' | 'a' REGEXP BINARY 'A' |
+---------------------+----------------+-----------------------+
|                   1 |              1 |                     0 |
+---------------------+----------------+-----------------------+

STRCMP(expr1, expr2)
expr1이 expr2와 일치하면 0을 반환하고, expr1이 expr2보다 문자열 정렬 순서상으로 앞에오면 -1을 반환하고, expr2이 expr2보다 문자열 정렬 순서상으로 뒤에 오면 1을 반환한다.
mysql> SELECT STRCMP('text', 'text2'), STRCMP('text', 'text'), STRCMP('text2', 'text');
+-------------------------+------------------------+-------------------------+
| STRCMP('text', 'text2') | STRCMP('text', 'text') | STRCMP('text2', 'text') |
+-------------------------+------------------------+-------------------------+
|                      -1 |                      0 |                       1 |
+-------------------------+------------------------+-------------------------+

MATCH (col1,col2,...) AGAINST (expr [search_modifier])
MySQL에서 대용량 데이터에 대한 FULL-TEXT 검색시 사용한다.
http://dev.mysql.com/doc/refman/5.6/en/fulltext-natural-language.html
http://dev.mysql.com/doc/refman/5.6/en/fulltext-boolean.html
http://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html




숫자

http://dev.mysql.com/doc/refman/5.6/en/numeric-functions.html

MySQL 산술 연산자

+: 더하기

-: 빼기

*: 곱하기

/: 나누기. 0으로 나누면 NULL을 반환한다.
mysql> SELECT 4 / 2, 1 / 3, 1 / 10, 1 / 13;
+--------+--------+--------+--------+
| 4 / 2  | 1 / 3  | 1 / 10 | 1 / 13 |
+--------+--------+--------+--------+
| 2.0000 | 0.3333 | 0.1000 | 0.0769 |
+--------+--------+--------+--------+

DIV: 정수 나누기
mysql> SELECT 4 DIV 2, 2 DIV 4, 4 DIV 3;
+---------+---------+---------+
| 4 DIV 2 | 2 DIV 4 | 4 DIV 3 |
+---------+---------+---------+
|       2 |       0 |       1 |
+---------+---------+---------+

%, MOD, MOD(N, M): 나머지
mysql> SELECT 4 % 2, 2 % 4, 4 % 3;
+-------+-------+-------+
| 4 % 2 | 2 % 4 | 4 % 3 |
+-------+-------+-------+
|     0 |     2 |     1 |
+-------+-------+-------+

- (마이너스): 기호를 변경한다.
mysql> SELECT -2;
+----+
| -2 |
+----+
| -2 |
+----+

ABS(X)
절대값

SIGN(X)
X가 음수: -1, 0: 0, 양수: 1
mysql> SELECT SIGN(-3), SIGN(0), SIGN(3.4);
+----------+---------+-----------+
| SIGN(-3) | SIGN(0) | SIGN(3.4) |
+----------+---------+-----------+
|       -1 |       0 |         1 |
+----------+---------+-----------+

FLOOR(X)
소수점 이하 버림. X보다 크지 않은 정수의 최대값을 반환한다.
mysql> SELECT FLOOR(1.1), FLOOR(-0.1), FLOOR(-1.1);
+------------+-------------+-------------+
| FLOOR(1.1) | FLOOR(-0.1) | FLOOR(-1.1) |
+------------+-------------+-------------+
|          1 |          -1 |          -2 |
+------------+-------------+-------------+

CEIL(X), CEILING(X)
소수점 이하 올림. X보다 작지 않은 정수의 최소값을 가져온다.
mysql> SELECT CEILING(1.1), CEILING(-0.1), CEILING(-1.1);
+--------------+---------------+---------------+
| CEILING(1.1) | CEILING(-0.1) | CEILING(-1.1) |
+--------------+---------------+---------------+
|            2 |             0 |            -1 |
+--------------+---------------+---------------+

ROUND(X)
반올림. X와 가장 가까운 정수를 가져온다.
mysql> SELECT ROUND(1), ROUND(0.49), ROUND(0.5);
+----------+-------------+------------+
| ROUND(1) | ROUND(0.49) | ROUND(0.5) |
+----------+-------------+------------+
|        1 |           0 |          1 |
+----------+-------------+------------+

ROUND(X, D)
반올림. X와 가장 가까운 소수점 D째 자리까지의 수를 반환한다. D가 0이면 소수점이 없는 값을 반환한다. D가 음수이면 소수점 상위를 의미한다.
mysql> SELECT ROUND(1, 1), ROUND(0.49, 1), ROUND(0.5, 0);
+-------------+----------------+---------------+-------------------+
| ROUND(1, 1) | ROUND(0.49, 1) | ROUND(0.5, 0) | ROUND(567.89, -2) |
+-------------+----------------+---------------+-------------------+
|           1 |            0.5 |             1 |               600 |
+-------------+----------------+---------------+-------------------+

POW(X, Y), POWER(X, Y)
X의 Y제곱 값을 반환한다.
mysql> SELECT POW(2, 3), POW(10, 3);
+-----------+------------+
| POW(2, 3) | POW(10, 3) |
+-----------+------------+
|         8 |       1000 |
+-----------+------------+

SQRT(X)
X의 제곱근을 반환한다.

PI()
원주율

COS(X) <-> ACOS(X)
코사인(Cosine)

SIN(X) <-> ASIN(X)
사인(Sine)

TAN(X) <-> COT(X)
탄젠트(Tangent)

RAND([N])
0에서 1 사이의 난수를 반환한다. 인자 N이 주어지면 seed값으로 사용된다.
동일한 seed값에 대한 난수 결과는 동일하다.
mysql> SELECT RAND(), RAND(), RAND(1), RAND(1);
+--------------------+---------------------+---------------------+---------------------+
| RAND()             | RAND()              | RAND(1)             | RAND(1)             |
+--------------------+---------------------+---------------------+---------------------+
| 0.9018138050118589 | 0.40212281923938803 | 0.40540353712197724 | 0.40540353712197724 |
+--------------------+---------------------+---------------------+---------------------+

LEAST(X, Y, ...)
인자 중에서 가장 작은 값을 반환한다.

GREATEST(X, Y, ...)
인자 중에서 가장 큰 값을 반환한다.

TRUNCATED(X, D)
버림. 숫자 X를 수소점 D 자리 까지만 남긴다. -D인 경우 소수점 위를 의미한다.
mysql> SELECT TRUNCATE(1.12, 1), TRUNCATE(1.519, 2), TRUNCATE(567.89, -2);
+-------------------+--------------------+----------------------+
| TRUNCATE(1.12, 1) | TRUNCATE(1.519, 2) | TRUNCATE(567.89, -2) |
+-------------------+--------------------+----------------------+
|               1.1 |               1.51 |                  500 |
+-------------------+--------------------+----------------------+




형변환

http://dev.mysql.com/doc/refman/5.6/en/cast-functions.html#function_cast


BINARY
문자열을 binary 문자열로 형변환 한다.
BINARY str 은 CAST(str AS BINARY)의 축약된 표기이다.
인덱스가 걸려있는 컬럼에 BINARY를 사용할 경우 인덱스가 효율적으로 사용되지 못한다.
mysql> SELECT 'A' = 'a', BINARY 'A' = 'a', 'A' = 'A ', BINARY 'A' = 'A ';
+-----------+------------------+------------+-------------------+
| 'A' = 'a' | BINARY 'A' = 'a' | 'A' = 'A ' | BINARY 'A' = 'A ' |
+-----------+------------------+------------+-------------------+
|         1 |                0 |          1 |                 0 |
+-----------+------------------+------------+-------------------+

CAST(expression AS type), CONVERT(expression, type)
expression은 형변환할 데이터이고 type은 변환할 타입이다.
type은 다음이 가능하다.

	* BINARY[(N)], CHAR[(N)], DATE, DATETIME, TIME, DECIMAL[(M[, D])], SIGNED [INTEGER], UNSIGNED [INTEGER]



수식에서 숫자값을 가지는 문자열은 자동으로 숫자로 형변환된다.
mysql> SELECT 1 + '1';
+---------+
| 1 + '1' |
+---------+
|       2 |
+---------+

문자열 처리가 필요한 상황에서의 숫자는 자동으로 문자열로 형변환된다.
mysql> SELECT CONCAT('ABC', 123);
+--------------------+
| CONCAT('ABC', 123) |
+--------------------+
| ABC123             |
+--------------------+




제어

http://dev.mysql.com/doc/refman/5.6/en/control-flow-functions.html


IFNULL(expr1, expr2)
expr1이 NULL이 아니면 expr1을 반환하고, NULL이면 expr2를 반환한다.
숫자 0은 NULL과 동일하게 취급되고, 문자 ''은 NULL과 동일하게 취급되지 않는다.
mysql> SELECT IFNULL(1, 0), IFNULL(0, 1), IFNULL(NULL, 10), IFNULL('', 'ABC');
+--------------+--------------+------------------+-------------------+
| IFNULL(1, 0) | IFNULL(0, 1) | IFNULL(NULL, 10) | IFNULL('', 'ABC') |
+--------------+--------------+------------------+-------------------+
|            1 |            0 |               10 |                   |
+--------------+--------------+------------------+-------------------+

NULLIF(expr1, expr2)
expr1 == expr2 이면 NULL을 반환한다. 그렇지 않으면 expr1을 반환한다.
CASE WHEN expr1 == expr2 THEN NULL ELSE expr1 END 와 같다.
mysql> SELECT NULLIF(1,1), NULLIF(1,2);
+-------------+-------------+
| NULLIF(1,1) | NULLIF(1,2) |
+-------------+-------------+
|        NULL |           1 |
+-------------+-------------+
mysql> SELECT NULLIF('A', 'a');
+------------------+
| NULLIF('A', 'a') |
+------------------+
| NULL             |
+------------------+

IF(expr1, expr2, expr3)
expr1 조건이 참이면(0이나 NULL이 아니면) expr2를 반환하고, 거짓이면 expr3를 반환한다.
mysql> SELECT IF(1 > 2, 2, 3), IF(1 < 2, 2, 3), IF(STRCMP('test', 'test1'), 'no', 'yes');
+-----------------+-----------------+------------------------------------------+
| IF(1 > 2, 2, 3) | IF(1 < 2, 2, 3) | IF(STRCMP('test', 'test1'), 'no', 'yes') |
+-----------------+-----------------+------------------------------------------+
|               3 |               2 | no                                       |
+-----------------+-----------------+------------------------------------------+
mysql> SELECT IF('A' = 'a', 'A = A', 'A != A');
+----------------------------------+
| IF('A' = 'a', 'A = A', 'A != A') |
+----------------------------------+
| A = A                            |
+----------------------------------+

CASE value WHEN [compare_value]
               THEN result
          [WHEN [compare_value]
               THEN result ...]
          [ELSE result]
END
value == compare_value이면 result를 반환한다.순서대로 WHEN을 계속 검사하며 조건을 만족하는 WHEN이 없으면 ELSE의 result를 반환한다. ELSE를 사용하지 않고 만족하는 조건이 없으면 NULL을 반환한다.
mysql> SELECT CASE 1 WHEN 1 THEN 'one'
    ->               WHEN 2 THEN 'two'
    ->                    ELSE 'more'
    -> END;
+-------------------------------------------------------------------------------+
| one                                                                           |
+-------------------------------------------------------------------------------+
mysql> SELECT CASE 'B' WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;
+----------------------------------------------+
| CASE 'B' WHEN 'a' THEN 1 WHEN 'b' THEN 2 END |
+----------------------------------------------+
|                                            2 |
+----------------------------------------------+
mysql> SELECT CASE BINARY 'B' WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;
+-----------------------------------------------------+
| CASE BINARY 'B' WHEN 'a' THEN 1 WHEN 'b' THEN 2 END |
+-----------------------------------------------------+
|                                                NULL |
+-----------------------------------------------------+

CASE WHEN [condition] 
         THEN result 
    [WHEN [condition] 
         THEN result ...] 
    [ELSE result]
END
mysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;
+--------------------------------------------+
| CASE WHEN 1>0 THEN 'true' ELSE 'false' END |
+--------------------------------------------+
| true                                       |
+--------------------------------------------+




그룹

http://dev.mysql.com/doc/refman/5.6/en/group-by-functions.html

그룹 함수는 질의문의 GROUP BY 절과 함께 사용되는 함수이다. 질의문에 GROUP BY 절이 생략된 경우에는 모든 row를 하나의 그룹으로 취급한다.
대부분의 그룹 함수는 조회된 row가 없는 경우에는 NULL을 반환한다.

COUNT([DISTINCT] expr)
SELECT로 조회된 결과 중에서 expr 컬럼에 대해 non-NULL 값을 가지는 row 수를 반환한다.
expr에 '*'를 지정하면 모든 row의 수를 반환한다.
mysql> SELECT COUNT(*), COUNT(DESCRIPTION) FROM PRODUCTS;
+----------+--------------------+
| COUNT(*) | COUNT(DESCRIPTION) |
+----------+--------------------+
|        8 |                  8 |
+----------+--------------------+
DISTINCT를 사용하면 중복되지 않은 COUNT만 계산한다.
mysql> SELECT COUNT(CUSTOMERS_ID), COUNT(DISTINCT CUSTOMERS_ID) FROM ORDERS;
+---------------------+------------------------------+
| COUNT(CUSTOMERS_ID) | COUNT(DISTINCT CUSTOMERS_ID) |
+---------------------+------------------------------+
|                   8 |                            6 |
+---------------------+------------------------------+

AVG([DISTINCT] expr)
평균값을 반환한다. 조회된 row가 없는 경우에는 NULL이 반환된다.
mysql> SELECT AVG(PRICE) FROM PRODUCTS;
+-------------+
| AVG(PRICE)  |
+-------------+
| 160125.0000 |
+-------------+
mysql> SELECT AVG(PRICE) FROM PRODUCTS WHERE PRICE < 10000;
+------------+
| AVG(PRICE) |
+------------+
|       NULL |
+------------+

MIN([DISTINCT] expr)
최소값을 가져온다. expr 컬럼의 값이 문자열인 경우 문자열 값이 가장 작은 문자열을 가져온다.
mysql> SELECT MIN(PRICE), MIN(NAME) FROM PRODUCTS;
+------------+------------------------+
| MIN(PRICE) | MIN(NAME)              |
+------------+------------------------+
|      12000 | Eastong 2020 스피커    |
+------------+------------------------+

MAX([DISTINCT] expr)
최대값을 가져온다. expr 컬럼의 값이 문자열인 경우 문자열 값이 가장 큰 문자열을 가져온다.
mysql> SELECT MAX(PRICE), MAX(NAME) FROM PRODUCTS;
+------------+--------------------+
| MAX(PRICE) | MAX(NAME)          |
+------------+--------------------+
|     525000 | 삼선 600 DVD 롬    |
+------------+--------------------+

SUM([DISTINCT] expr)
합계를 반환한다. 조회된 row가 없는 경우에는 NULL이 반환된다.
mysql> SELECT SUM(PRICE) FROM PRODUCTS;
+------------+
| SUM(PRICE) |
+------------+
|    1281000 |
+------------+

STD(expr), STDDEV(expr)
표준편차를 반환한다.

GROUP_CONCAT(expr [ORDER BY {col_name | expr} [ASC|DESC]] [SEPERATOR seperatorStr])
결과 문자열을 연결하여 반환한다. 기본적으로 ','로 연결된다.
mysql> SELECT GROUP_CONCAT(NAME) FROM CUSTOMERS;
+--------------------------------------------------------------------------------------------------------+
| GROUP_CONCAT(NAME)                                                                                     |
+--------------------------------------------------------------------------------------------------------+
| 방정환,한용운,김정호,허난설헌,우장춘,장영실,안익태,신사임당,허준,황진이                                |
+--------------------------------------------------------------------------------------------------------+
SEPERATOR를 지정하면 구분자를 명시할 수 있다.
mysql> SELECT GROUP_CONCAT(NAME SEPARATOR '>') FROM CUSTOMERS;
+--------------------------------------------------------------------------------------------------------+
| GROUP_CONCAT(NAME SEPARATOR '>')                                                                       |
+--------------------------------------------------------------------------------------------------------+
| 방정환>한용운>김정호>허난설헌>우장춘>장영실>안익태>신사임당>허준>황진이                                |
+--------------------------------------------------------------------------------------------------------+
ORDER BY를 사용하여 정렬 순서를 지정할 수 있다.
mysql> SELECT GROUP_CONCAT(NAME ORDER BY NAME SEPARATOR '>') FROM CUSTOMERS;
+--------------------------------------------------------------------------------------------------------+
| GROUP_CONCAT(NAME ORDER BY NAME SEPARATOR '>')                                                         |
+--------------------------------------------------------------------------------------------------------+
| 김정호>방정환>신사임당>안익태>우장춘>장영실>한용운>허난설헌>허준>황진이                                |
+--------------------------------------------------------------------------------------------------------+




기타 명령어


DATABASE()
현재 사용하고 있는 DATABASE의 이름을 가져온다.
mysql> SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| shopsample |
+------------+

USER(), SYSTEM_USER(), SESSION_USER()
현재의 MySQL 사용자를 호스트 이름과 함께 반환한다.
mysql> SELECT USER(), SYSTEM_USER(), SESSION_USER(), SUBSTRING_INDEX(USER(), '@', 1);
+-------------------+-------------------+-------------------+---------------------------------+
| USER()            | SYSTEM_USER()     | SESSION_USER()    | SUBSTRING_INDEX(USER(), '@', 1) |
+-------------------+-------------------+-------------------+---------------------------------+
| mystudy@localhost | mystudy@localhost | mystudy@localhost | mystudy                         |
+-------------------+-------------------+-------------------+---------------------------------+


http://dev.mysql.com/doc/refman/5.6/en/encryption-functions.html

PASSWORD(str)
문자열 str을 암호화한다. 유닉스 시스템의 암호화와 다른 방식이며, 암호화된 데이터의 원래 값은 가져올 수 없다.
mysql> SELECT PASSWORD('asdf'), PASSWORD('ASDF');
+-------------------------------------------+-------------------------------------------+
| PASSWORD('asdf')                          | PASSWORD('ASDF')                          |
+-------------------------------------------+-------------------------------------------+
| *7F0C90A004C46C64A0EB9DDDCE5DE0DC437A635C | *C639216FD25A1CBF82D351AD19B78F6B0A8E2150 |
+-------------------------------------------+-------------------------------------------+

ENCRYPT(str[, salt])
유닉스 시스템의 암호화 매커니즘인 CRYPT()를 호출하여 암호화를 호출한다. 윈도우 시스템에서는 NULL을 반환한다.

ENCODE(str, pass_str)
문자열 str을 pass_str을 이용하여 암호화한다. DECODE() 함수를 이용하여 복호화할 수 있다.
DECODE(crypt_str, pass_str)
ENCODE() 함수로 암호화된 문자열 crypt_str을 pass_str을 이용하여 복호화한다.
mysql> SELECT ENCODE('ABC', '1'), DECODE(ENCODE('ABC', '1'), '1');
+--------------------+---------------------------------+
| ENCODE('ABC', '1') | DECODE(ENCODE('ABC', '1'), '1') |
+--------------------+---------------------------------+
| (¼K               | ABC                             |
+--------------------+---------------------------------+

MD5(string)
string을 MD5 128 비트 축약 알고리즘에 의해 hash 값으로 변환한다. 결과값으로 16진수로 이루어진 32자리 문자열이 반환된다. 무결성을 보장하기 때문에 데이터에 대한 서명 인증 등에 사용된다.
mysql> SELECT MD5("TEST");
+----------------------------------+
| MD5("TEST")                      |
+----------------------------------+
| 033bd94b1168d7e4f0d644c3c95e35bf |
+----------------------------------+

SHA1(string), SHA(string)
string 을 SHA 알고리즘(RFC 3174, Secure Hash Algorithm)에 의해 160 비트 길이의 축약된 데이터로 변환한다. 결과값으로 16진수로 이루어진 40자리 문자열이 반환된다. MD5보다 무결성 측면에서 안전하지만 속도는 조금 느리다.
mysql> SELECT SHA("TEST"), SHA1("TEST");
+------------------------------------------+------------------------------------------+
| SHA("TEST")                              | SHA1("TEST")                             |
+------------------------------------------+------------------------------------------+
| 984816fd329622876e14907634264e6f332e9fb3 | 984816fd329622876e14907634264e6f332e9fb3 |
+------------------------------------------+------------------------------------------+

SHA2(str, hash_length)
SHA-2 알고리즘군(SHA-224, SHA-256, SHA-384, SHA-512)을 사용하여 변환한다. hash_length는 결과 bit 수를 지정하며 224, 256, 384, 512, 0(256과 동일) 중의 하나여야 한다.
MD5(), SHA1() 보다 안전한 암호화 방법으로 고려될 수 있다.
mysql> SELECT SHA2('abc', 224);
+----------------------------------------------------------+
| SHA2('abc', 224)                                         |
+----------------------------------------------------------+
| 23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7 |
+----------------------------------------------------------+
mysql> SELECT SHA2('abc', 384);
+--------------------------------------------------------------------------------------------------+
| SHA2('abc', 384)                                                                                 |
+--------------------------------------------------------------------------------------------------+
| cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7 |
+--------------------------------------------------------------------------------------------------+

AES_ENCRYPT(string, key_string)
AES_DECRYPT(string, key_string)
AES 알고리즘

DES_ENCRYPT(string_to_encrypt[, (key_number | key_string)])
DES_DECRYPT(string_to_encrypt[, key_string])
DES 알고리즘


LAST_INSERT_ID([expr])
AUTO_INCREMENT로 지정된 컬럼에 가장 최근에 자동 생성되어 저장된 데이터 값을 가져온다.
mysql> SELECT LAST_INSERT_ID();


FORMAT(X, D)
숫자 X를 '#,###,###.##'와 같은 식의 숫자형으로 포맷하여 소수점 D자리까지 표시한다. D가 0이면 소수점을 표시하지 않는다.
mysql> SELECT FORMAT(12332.123456, 4), FORMAT(12332.1,4), FORMAT(12332.2,0);
+-------------------------+-------------------+-------------------+
| FORMAT(12332.123456, 4) | FORMAT(12332.1,4) | FORMAT(12332.2,0) |
+-------------------------+-------------------+-------------------+
| 12,332.1235             | 12,332.1000       | 12,332            |
+-------------------------+-------------------+-------------------+

VERSION()
MySQL 서버 버전을 가져온다.
mysql> select version();
+------------+
| version()  |
+------------+
| 5.6.14-log |
+------------+

CONNECTION_ID()
MySQL 서버로 부터 부여받은 Connection ID(Thread ID)를 가져온다.
mysql> select connection_id();
+-----------------+
| connection_id() |
+-----------------+
|              14 |
+-----------------+

BENCHMARK(count, expr)
벤치마킹 측정에 사용할 수 있는 함수이다. expr을 count 만큼 실행한다. 실행 후의 결과는 무조건 0이다.
실행 후 화면에 표시되는 경과 시간 값은 서버의 CPU 시간이 아니라 클라이언트에서 해당 SQL 문장의 수행에 걸린 시간이다.
mysql> select benchmark(1000000, encode('hello', 'goodbye'));
+------------------------------------------------+
| benchmark(1000000, encode('hello', 'goodbye')) |
+------------------------------------------------+
|                                              0 |
+------------------------------------------------+
1 row in set (0.42 sec)
mysql> select benchmark(10000000, encode('hello', 'goodbye'));
+-------------------------------------------------+
| benchmark(10000000, encode('hello', 'goodbye')) |
+-------------------------------------------------+
|                                               0 |
+-------------------------------------------------+
1 row in set (2.77 sec)

FOUND_ROWS()
최 근에 SQL_CALC_FOUND_ROWS 지시어와 함께 실행된 SELECT문의 결과 row의 개수를 가져온다. 앞 단계에서 추출했던 row의 수를 빠르게 가져올 때 사용한다. 주의 사항은 LIMIT의 영향을 받지 않는다. LIMIT으로 4개 row만 가져와도 실제 조회 대상 row의 수를 반환한다.
mysql> SELECT SQL_CALC_FOUND_ROWS * FROM ORDERS;
+-----------+--------------+-------------+
| orders_id | customers_id | orders_date |
+-----------+--------------+-------------+
|         3 |           12 | 2002-09-05  |
|         7 |            8 | 2002-09-06  |
|         8 |            4 | 2002-09-06  |
|         9 |            4 | 2002-09-08  |
|        13 |           16 | 2002-09-11  |
|        15 |            2 | 2002-09-12  |
|        16 |           15 | 2002-09-12  |
|        17 |            2 | 2002-09-13  |
+-----------+--------------+-------------+
8 rows in set (0.00 sec)

mysql> SELECT FOUND_ROWS();
+--------------+
| FOUND_ROWS() |
+--------------+
|            8 |
+--------------+




기타 명령어

함수 사용법 조회
> HELP <함수명>

데이터베이스 생성
> CREATE DATABASE <databasename>;

데이터베이스 삭제
> DROP DATABASE [IF EXISTS] <databasename>;

데이터베이스 보기
> SHOW DATABASES;

데이터베이스 사용 선언
> USE <databasename>;

사용자 생성
> GRANT ALL ON <database_name>.* TO '<username>'@'localhost' IDENTIFIED BY '<password>';

테이블 목록 조회
> SHOW TABLES;

테이블 구조 조회
> DESC <tablename>;

SQL 파일 실행
> SOURCE <file full path>
(문장 끝에 ';'를 붙이지 않음)

* MySQL 테이블 주석 조회
SHOW FULL COLUMNS FROM xe_cp_coupangs;
SHOW FULL COLUMNS FROM xe_cp_options;




관리/모니터링 명령어

> SHOW PROCESSLIST;
현재 서버에서 수행 중인 프로세스의 목록을 표시한다. 수행중인 SQL과 Lock 상태인지 등을 확인할 수 있다.
mysql> show processlist;
+----+---------+----------------+------+---------+------+-------+------------------+
| Id | User    | Host           | db   | Command | Time | State | Info             |
+----+---------+----------------+------+---------+------+-------+------------------+
|  2 | mystudy | localhost:2283 | NULL | Query   |    0 | init  | show processlist |
+----+---------+----------------+------+---------+------+-------+------------------+


스토리지 엔진과 기본 설정 등에 대한 조회
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+




트랜잭션

MySQL은 기본적으로 AUTOCOMMIT 모드로 동작한다.

AUTOCOMMIT
mysql> SET AUTOCOMMIT = 0; # AUTOCOMMIT 끄기(0:FALSE)
mysql> SET AUTOCOMMIT = 1; # AUTOCOMMIT 켜기(1:TRUE)

COMMIT
mysql> COMMIT;

ROLLBACK
mysql> ROLLBACK;


------------------------------------------------------------------
MySQL & Oracle 비교
------------------------------------------------------------------
1. select concat(empno, ':', ename) as name,  if((ename = 'KING'), "I\'m Boss", 'I\'m Employee'), round(ifnull((sal+sal/13+comm), 100), 2) as wage 
             from emp 
                where empno between 7600 and 7900 
                order by ename asc ;


2. select ename, substr(ename, 2, 2), round(sal/13,1), sal%13, date_format(hiredate, '%Y/%m/%d') as 'start date' 
            from emp 
                where ename like '%LA%' and sal > 2500 ;


3. select ename, substr(ename, 2, 2), cast(sal as char) salary, round(sal/13,1), sal%13, date_format(hiredate, '%Y/%m/%d') as 'start date' 
           fromemp 
               where ename like '%LA%' andsal > 2500


4. select job, sum(sal) payroll 
          from emp 
              group by job 
              having sum(sal) > 5000 
              order by job desc;


5. select ename, job 
          from emp 
              where job = (select job from emp where ename = 'SMITH');


6. select ename, sal, s.avgsal 
          from emp e, (select avg(sal) avgsal from emp) s 
              where e.sal < s.avgsal


7. select ename, job, deptno 
          from emp 
             where deptno in (select deptno from dept where dname = 'SALES');


8. select b.* 
          from (select empno, ename, job, mgr, hiredate, sal, comm, deptno from emp a where deptno > 10 ) b 
             where b.sal > 1000 
             order by b.ename asc limit 2, 5


9. select @ROWNUM := @ROWNUM+1 as ROWNUM, empno, ename 
         from emp, ( SELECT @ROWNUM:=0 ) a limit 3 , 5








- http://blog.naver.com/zooc80/90009667364
Oracle쿼리문을 MySQL 쿼리로 변환

1. 인덱스 힌트 제거한다.
2. NVL 함수를  IFNULL 함수로 변경한다.
3. SYSDATE 함수를 NOW() 함수로 변경한다.
4. TRUNC(SYSDATE)를 CURDATE()로 변경한다.
    trunc(sysdate)를 하면 시간만 잘린 일자가 나온다.
    MySQL에서 날자만 반환해주는 CURDATE()를 쓴다.

    CURDATE()와 날짜 값을 비교하기 위해서는 비교날자를 
    DATE_FORMAT('20061020','%Y-%m-%d')로 변환

5. Outerjoin 변경 
[Oracle]
left outer joing : SELECT t1.*, t2.* FROM t1, t2 where t1.i1 = t2.i2(+);
right outer joing: SELECT t1.*, t2.* FROM t1, t2 where t1.i1(+) = t2.i2; 

[MySQL] 
left outer joing : SELECT t1.*, t2.* FROM t1 LEFT OUTER JOIN t2 ON t1.i1 = t2.i2;
right outer joing: SELECT t1.*, t2.* FROM t1 RIGHT OUTER JOIN t2 ON t1.i1 = t2.i2;

% From절에서 테이블명 중간에 , 가 없다는것과 ON 구문이 From절 바로 뒤에 오게
   해야하는것에 주의 

6. TO_CHAR()를 DATE_FORMAT()으로 변환한다.

    TO_CHAR(sysdate,'YYYYMMDD')의 경우
    DATE_FORMAT(now(),'%Y%m%d')로 변환
 
     자바스크립트의 요일은(0-6), MySQL의 요일은(0-6), ORACLE의 요일은(1,7)
    그러므로 자바스크립트와 오라클의 요일차이로 TO_CHAR(SYSDATE-1, 'D')를
    그대로 변경 시키면 아래구문이지만 
    => DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 DAY), '%w')
 
     MySQL에서는 -1을 할 필요가 없으므로
     => DATE_FORMAT(NOW(), '%w') ")
 
7. TO_DATE()를 DATE_FORMAT()으로 변환한다.

    TO_DATE('20061020','YYYYMMDD')의 경우
    DATE_FORMAT('20061020','%Y%m%d')로 변환

8. Where rownum <= 10 을 limit 10으로 변환 (rownum은 mysql에 없어 limit를 사용)

   rownum >= 5 와 rownum <= 10 이면 limit 4, 5
   ex) 리스트 페이징에서 11번째부터 20번째까지 limit 10, 10  
 
   처음부터 10개             ........ LIMIT 10
   5번째부터 10개            ........LIMIT 4, 10
   5번째부터 마지막까지  .... LIMIT 4, -1
 
  이때 주의 할 점은 첫번째 레코드의 시작은 “0” 입니다.
  즉 “LIMIT 1, 3 - 2번째부터 3개” 의 결과를 출력하게 됩니다.

9. Subquery에서 alias가 없다면 붙인다. 
   예를 들면 
    select a, b from ( select a, b from ttt)  
--> select t.a, t.b from ( select a, b from ttt) t
 
10. DELETE 테이블명 쿼리문을 DELETE FROM 테이블명 쿼리문으로 바꾸어준다.
    
     오라클에서는 FROM을 생략해도 되지만 MySQL에서는 꼭 붙여준다.
 
 
11. Merge into의 경우는 쿼리문을 분리하여 DAO단에서 처리로직으로 변경해준다.
     변경방법은 아래 두가지중에 하나를 선택해도 되고 다른 방법을 써도 된다.
     자세한 예제는 첨부문서 참고
 
      (1) 조건이 맞는지(MATCHED)에 대한 SELECT문을 실행시켜서 결과값이
           있으면 UPDATE문을 실행시켜 주고 결과값이 없으면 INSERT문을
           실행시켜준다.
           % rs.next()로 결과값이 있는지 판단
 
      (2) UPDATE문을 실행해서 UPDATE가 일어나면 그대로 가고 UPDATE가
           일어나지 않으면 INSERT문을 실행시킨다.
           % ps.executeUpdate() > 0으로 UPDATE 판단
[출처] Oracle쿼리문을 MySQL 쿼리로 변환|작성자 닭죽
[출처] Oracle쿼리문을 MySQL 쿼리로 변환|작성자 닭죽




- http://cacung82.blog.me/220219070134
Oracle과 MySql 쿼리문 비교 



Oracle에 익숙한 필자는.. 이번 프로젝트에서 생전 처음으로 MariaDB를 쓰면서 MySql 문법을 익혀야 했다.
지금부터 알게된 모든 차이점들을 하나씩 하나씩 차근차근 적어나갈 생각이다.
규칙은, 기준이 Oracle이고 그 비교되는 Mysql 문법을 아래에 적는다.


1. 공백치환 함수 ( NVL -> IFNULL )
Oracle : SELECT NVL('컬럼명', '') FROM DUAL;
MySql : SELECT IFNULL('컬럼명', '') FROM DUAL;


2. 현재 날짜시간
Oracle : SYSDATE
Mysql  : NOW() 


3. 날짜포멧 
Oracle : TO_CHAR(sysdate,'MMDDYYYYHH24MISS')
Mysql  : DATE_FORMAT(now(),'%Y%m%d%H%i%s')  -> 여기서 대문자Y는 4자리 년도, 소문자 y는 2자리 년도


4. 날짜 포멧 : 요일
Oracle : 요일이 1~7로 인식함  -> TO_CHAR(SYSDATE - 1, 'D') 
Mysql : 요일이 0~6으로 인식   -> DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 DAY), '%w')
* 참고로 자바스크립트가 0~6으로 인식하기에 Oracle 쿼리에서 -1을 해서 맞추는 경우가 많음

5. Like절 '%' 사용법
Oracle : Like '%'||'문자'||'%' 이런식으로 컬럼명 앞뒤로 '%'를 붙여주면 된다
Mysql : LIKE CONCAT('문자','%') 이런식으로 CONCAT 함수 사용

6. 형변환
Oracle : To_char, To_number 등
Mysql : CAST
SELECT TO_CHAR(1234) FROM DUAL 
-> SELECT CAST(1234 AS CHAR) FROM DUAL

7. MYSQL은 대소문자 구분함

8. ROWNUM
Oracle : where 절에 rownum > 5 and rownum =< 10 
Mysql : where절 없이 limit 5,10


9. Sequence(시퀀스)는 둘 다 사용자함수를 만들어서 아래와 같이 사용
Oracle : 시퀀스명.nextval
Mysql : 시퀀스명.currval


10. 문자열 자르기
Oracle: SUBSTR(컬럼명, 1, 10)
Mysql: SUBSTRING(컬럼명, 1,10)



11. 문자열 합치기 ( - 문자열을 연결한다고 가정)
Oracle: 문자열(또는 컬럼) ||' - '
Mysql: CONCAT(문자열(또는 컬럼), ' - ')















계속해서 업데이트 하고 있는 페이지입니다.
좀 더 많은 비교를 해주실 분들은 아래 댓글로 알려주세요^^




-  http://visionboy.me/main/board_view.php?no=407&page=1&tb_id=bd6
Oracle쿼리문을 MySQL쿼리로 변환 방법

Oracle을 쓰다가 MySQL을 사용하는 경우는 많지 않습니다. 워낙 강력한 DBMS라 Oracle을 버리기 어렵습니다.
대부분 변경한다고 하면 License문제로 변경하거나 솔루션에 DB를 추가로 적용 가능하게 하는 정도?
어째든 이번에 Oracle을 MySQL로 변경 할 일이 생겨 정리하여 블로그에 올립니다. ^^

1. NVL 함수를  IFNULL 함수로 변경한다.

2. SYSDATE 함수를 NOW() 함수로 변경한다.

3. trunc(sysdate)를 하면 시간만 잘린 일자가 나온다.
MySQL에서 날자만 반환해주는 CURDATE()를 쓴다.

4. Sequence는 사용자 함수를 만들어 사용한다.
사용자 함수 만드는 방법
http://blog.naver.com/steelcatx/60184547400

SELECT zon_sq01.nextval FROM dual; -> SELECT get_next_seq_val('zon_sq01') FROM dual;
SELECT zon_sq01.currval FROM dual; -> SELECT get_curr_seq_val('zon_sq01') FROM dual;

sequence 추가가 필요할시 mysql_seq_table에 seq_nm(시퀀스명), last_cached_val(마지막 사용된 값)를 입력한다.

5. 인덱스 힌트 제거한다.
있더라도 큰 영향 없으므로 대상에서 제외

6. Date 함수 관련
6-1. TO_CHAR()를 DATE_FORMAT()으로 변환한다.
TO_CHAR(sysdate,'MMDDYYYYHH24MISS')의 경우
DATE_FORMAT(now(),'%m%d%Y%H%i%s')로 변환 -- '%Y%m%d' 대소문자 주의!!! Y는 4자리, y는 2자리, %m은 12기준 %M은 24기준

6-2. 요일 변경
자바스크립트의 요일은(0-6), MySQL의 요일은(0-6), ORACLE의 요일은(1,7)
그러므로 자바스크립트와 oracle의 요일차이로 TO_CHAR(SYSDATE-1, 'D')를
그대로 변경 시키면 아래구문이지만
=> DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 DAY), '%w')

MySQL에서는 -1을 할 필요가 없으므로
=> DATE_FORMAT(NOW(), '%w')

6-3. TO_DATE()를 STR_TO_DATE()으로 변환한다.
TO_DATE('10/30/2012 00:00:00', 'MM/DD/YYYY HH24:MI:SS')의 경우
=> STR_TO_DATE('10/30/2012 00:00:00', '%m/%d/%Y %H:%i:%s')로 변환

TRUNC(to_date('20130227', 'YYYYMMDD')+30) 의 경우
=> DATE_ADD(str_to_date('20130227', '%Y%m%d'), INTERVAL 30 DAY) -- '%Y%m%d' 대소문자 주의!!! Y는 4자리, y는 2자리, %m은 12기준 %M은 24기준

6-4. 날짜 가감
oracle은 날짜형 데이터에 +1을 하면 1일이 추가되나 mysql은 이상하게 변함.
sysdate + 1
=> DATE_ADD(now(), interval 1 DAY)

DATE_ADD(date,INTERVAL expr  unit) -- 날짜 가산
DATE_SUB(date,INTERVAL expr  unit) -- 날짜 감산
DATE_ADD, DATE_SUB를 사용 할 경우 '0000-00-00 00:00:00'나 '0000/00/00 00:00:00'의 형태만 맞춰 주면 문자도 자동으로 변경하여 연산됨.

unit Value expr 형태
MICROSECOND MICROSECONDS
SECOND SECONDS
MINUTE MINUTES
HOUR HOURS
DAY DAYS
WEEK WEEKS
MONTH MONTHS
QUARTER QUARTERS
YEAR YEARS
SECOND_MICROSECOND 'SECONDS.MICROSECONDS'
MINUTE_MICROSECOND 'MINUTES:SECONDS.MICROSECONDS'
MINUTE_SECOND 'MINUTES:SECONDS'
HOUR_MICROSECOND 'HOURS:MINUTES:SECONDS.MICROSECONDS'
HOUR_SECOND 'HOURS:MINUTES:SECONDS'
HOUR_MINUTE 'HOURS:MINUTES'
DAY_MICROSECOND 'DAYS HOURS:MINUTES:SECONDS.MICROSECONDS'
DAY_SECOND 'DAYS HOURS:MINUTES:SECONDS'
DAY_MINUTE 'DAYS HOURS:MINUTES'
DAY_HOUR 'DAYS HOURS'
YEAR_MONTH 'YEARS-MONTHS'

예)
SELECT DATE_ADD('1900-01-01 00:00:00', INTERVAL '-1 10' DAY_HOUR);
-> '1899-12-30 14:00:00' -- 34시간이 감산됨
SELECT DATE_ADD('1900-01-01 00:00:00', INTERVAL '1 -10' DAY_HOUR);
-> '1900-01-02 10:00:00' -- 34시간이 가산됨

6-5. 날짜와 날짜의 차이 구하기
SELECT to_date('20130314', 'YYYYMMDD')- to_date('20130313', 'YYYYMMDD') FROM DUAL -- 1일 이 조회됨
-> SELECT TO_DAYS(str_to_date('20130314', '%Y%m%d'))- TO_DAYS(str_to_date('20130313', '%Y%m%d')) FROM DUAL


7. Outerjoin 변경
[Oracle]
left outer joing : SELECT t1.*, t2.* FROM t1, t2 where t1.i1 = t2.i2(+);
right outer joing: SELECT t1.*, t2.* FROM t1, t2 where t1.i1(+) = t2.i2;

[MySQL]
left outer joing : SELECT t1.*, t2.* FROM t1 LEFT OUTER JOIN t2 ON t1.i1 = t2.i2;
right outer joing: SELECT t1.*, t2.* FROM t1 RIGHT OUTER JOIN t2 ON t1.i1 = t2.i2;

% From절에서 테이블명 중간에 , 가 없다는것과 ON 구문이 From절 바로 뒤에 오게
해야하는것에 주의

8. rownum 변환
8-1. rownum이 조건으로 사용될 경우 limit를 사용
rownum >= 5 와 rownum <= 10 이면 limit 4, 5
ex) 리스트 페이징에서 11번째부터 20번째까지 limit 10, 10
처음부터 10개 ... LIMIT 10
5번째부터 10개 ... LIMIT 4, 10
5번째부터 마지막까지 ... LIMIT 4, -1

이때 주의 할 점은 첫번째 레코드의 시작은 “0”
즉 “LIMIT 1, 3 - 2번째부터 3개” 의 결과를 출력
예)
select * from table LIMIT 1, 3;
8-2. rownum이 컬럼으로 사용될 경우 변수 사용
select @rownum := @rownum + 1 as rownum
, table.*
from table
JOIN (select @rownum := 0) r;
8-3. rownum이 조건 및 컬럼으로 모두 사용될 경우 2.를 적용한 서브쿼리로 작성
select *
from (
select @rownum := @rownum + 1 as rownum
, table.*
from table
JOIN (select @rownum := 0) r
)
where rownum < 3;

9. Subquery에서 alias가 없다면 붙인다. 
select a, b from ( select a, b from ttt) 
--> select t.a, t.b from ( select a, b from ttt) t

10. DELETE 테이블명 쿼리문을 DELETE FROM 테이블명 쿼리문으로 바꾸어준다.
oracle에서는 FROM을 생략해도 되지만 MySQL에서는 반드시 필요

11. Merge into의 경우는 쿼리문을 분리하여 처리로직으로 변경해준다.
변경방법은 아래 두가지중에 하나를 선택해도 되고 다른 방법을 써도 된다.
11-1 조건이 맞는지(MATCHED)에 대한 SELECT문을 실행시켜서 결과값이 있으면 UPDATE문을 실행시켜 주고 결과값이 없으면 INSERT문을 실행시켜준다.

11-2 UPDATE문을 실행해서 UPDATE가 일어나면 그대로 가고 UPDATE가 일어나지 않으면 INSERT문을 실행시킨다.

12. decode문 case로 변경
decode( 1,1,'true','false') -> case when 1=1 then 'true' else 'false' end

13. start with connet by 문은 with를 사용한 recursive 쿼리로 변경
recursive 쿼리 작성 방법
http://blog.naver.com/steelcatx/60186185102

14. mysql은 대소문자 구분함. 모든 컬럼명과 테이블명의 대소문자 확인

15. 오라클의 ||(Vertical Bar) 사용할 수없음. CONCAT으로 변경
TO_CHAR(NOW(), 'yymmdd') || LPAD(get_next_seq_val('ord_cl_info_sq01'), 9, '0')
--> CONCAT(DATE_FORMAT(NOW(), '%y%m%d') ,LPAD(get_next_seq_val('ord_cl_info_sq01'), 9, '0'))

16. TO_CHAR, TO_NUMBER -> CAST로 변경
SELECT TO_CHAR( 11 ) AS AA FROM DUAL
--> SELECT CAST( 11 AS CHAR ) AS AA FROM DUAL
SELECT TO_NUMBER( '-11' ) AS AA FROM DUAL
--> SELECT CAST( '-11' AS SIGNED ) AS AA FROM DUAL

[출처] Oracle쿼리문을 MySQL쿼리로 변환 방법|작성자 강철고양이








